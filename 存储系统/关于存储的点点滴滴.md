# 我的存储笔记
## 存储理论
### 文件系统的实现
首先理论方面的学习，主要是先抽象出一个极简的文件系统,再看看现实中的案例。

#### 数据结构
文件系统在磁盘上使用什么类型的结构来组织数据和元数据
简单的文件系统可以是这样：
![file](../statics/Screenshot_20230807_171910_Edge.jpg)

上图为一小块磁盘区域的数据内容，其中：
* 磁盘被分为64个小块(block)，每块大小为4KB
* "D"代表数据，为用户数据的代表
* "I"代表inode，为存放文件元数据的结构
* "d"代表数据位图和inode位图，是一种用于管理空闲块的数据结构
* "i"代表inode位图，用于管理inode块的数据结构
* "S"代表超级块，用于存储文件系统本身的信息

放大0-7数据块(管理结构)的内容：
![inode](../statics/Screenshot_20230807_173332_Edge.jpg)
假设说，我现在希望获取inode32的数据，通过计算得知我需要获得第20KB位（inode大小为256字节）的数据 -> 文件系统要索引这个字节位的数据。但是磁盘是由可寻址扇区组成的(固态硬盘使用闪存芯片存储数据，闪存芯片被分为多个可寻址的扇区，每个扇区都有唯一地址)，通常扇区是512字节，从而文件系统需要向40发出一个读取请求。

除了纯粹数据外的用户数据统称为元数据，设计inode时，最重要的决定之一是它如何引用数据块的位置，一个简单的方法是，将磁盘地址直接写入到inode中，使用这种方法有一个局限性是，对于很大的文件，将没有足够的空间来纳入这些地址。为了解决这类问题，人们想到了**多级索引**

分配一个块专门存其他块的地址，INODE设置12个（举例）直接指针和一个间接指针，一个块可以存1024个指针，则文件上限上涨至4144KB。想要继续扩容，则继续套娃。许多文件系统使用套娃（多级索引）的方法来满足文件大小上限的需求，比如ext2,ext3。

### IO的应用层面分析

#### 一次IO的代价

#### 通信层面-json和msgpack

#### 访问方法

#### 存储特征和存储应用设计


## 存储工具

### 存储追踪工具：blktrace
`blktrace`是块IO层级的追踪工具，当你要了解每个下发到块设备的IO操作时，blktrace是最合适的工具，该工具还服务于IO领域内的内核开发者
对比一下,blktrace和iostat：iostat提供了获取向目标设备的请求队列获取信息的能力，但并不覆盖每一个IO



### 有哪些衡量指标

### 有哪些测试基准

### 