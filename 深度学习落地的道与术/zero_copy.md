## 零拷贝的语境

很多人喜欢造概念，零拷贝这个词，我们经常能听到。

但是当我们坐下来严肃地讨论相关的内容时，我们必须得明确上下文。



从数据迁移的角度考虑，零拷贝不一定是真的“完全不需要进行内存的拷贝”，而是避免拷贝所有数据，从而占用了更少的资源（时间资源，或者是其他的）



在到更加具体的场景当中，我们使用json文件存储数据，当我们进行“零拷贝反序列化”，我们一定会把数据从磁盘中（假如json数据没有格式错误）load到一段内存中，但这离将数据转换为runtime（比如Python解释器中）的数据结构（某一个PyOjbect）还是有一定距离的，假如说，前面分配的内存中，某一个字段的值和PyObject中对应字段的值是完全一致的，那我们只需要让后者指向前者的内存地址，就可以去利用它。从这个角度来说，我们就算是避免了/完成零拷贝反序列化。



放到Rust语境下，这必然涉及到一个相关概念：生命期。现在，我们来展开



## 相关技术

### Cow(copy on write)

先贴个维基百科的链接：https://en.wikipedia.org/wiki/Copy-on-write



#### overview

通过维基百科，先建立一个基础的认识：

cow是一种资源管理技术，其内涵是只有当需要修改资源时，才会对原数据进行拷贝。

这很显然主要是为了节省资源。（还记得我们讲到UnionFs的时候涉及到的内容吗？没错，那也是一项实际应用）



#### Rust视角

假想存在这么一种类型，他一定很复杂，因为需要考虑到它生命期/所有权相关的设计。

简言之，就是可选所有权



#### 实例代码



#### utf8字符串案例



#### 原理&优化点



## 零拷贝反序列化

