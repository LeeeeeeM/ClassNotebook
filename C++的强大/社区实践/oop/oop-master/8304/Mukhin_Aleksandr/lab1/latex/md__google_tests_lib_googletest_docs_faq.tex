\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md210}{}\doxysection{Why should test suite names and test names not contain underscore?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md210}
Underscore ({\ttfamily \+\_\+}) is special, as C++ reserves the following to be used by the compiler and the standard library\+:


\begin{DoxyEnumerate}
\item any identifier that starts with an {\ttfamily \+\_\+} followed by an upper-\/case letter, and
\item any identifier that contains two consecutive underscores (i.\+e. {\ttfamily \+\_\+\+\_\+}) {\itshape anywhere} in its name.
\end{DoxyEnumerate}

User code is {\itshape prohibited} from using such identifiers.

Now let\textquotesingle{}s look at what this means for {\ttfamily T\+E\+ST} and {\ttfamily T\+E\+S\+T\+\_\+F}.

Currently {\ttfamily T\+E\+S\+T(\+Test\+Suite\+Name, Test\+Name)} generates first class named {\ttfamily Test\+Suite\+Name\+\_\+\+Test\+Name\+\_\+\+Test}. What happens if {\ttfamily Test\+Suite\+Name} or {\ttfamily Test\+Name} contains {\ttfamily \+\_\+}?


\begin{DoxyEnumerate}
\item If {\ttfamily Test\+Suite\+Name} starts with an {\ttfamily \+\_\+} followed by an upper-\/case letter (say, {\ttfamily \+\_\+\+Foo}), we end up with {\ttfamily \+\_\+\+Foo\+\_\+\+Test\+Name\+\_\+\+Test}, which is reserved and thus invalid.
\item If {\ttfamily Test\+Suite\+Name} ends with an {\ttfamily \+\_\+} (say, {\ttfamily Foo\+\_\+}), we get {\ttfamily Foo\+\_\+\+\_\+\+Test\+Name\+\_\+\+Test}, which is invalid.
\item If {\ttfamily Test\+Name} starts with an {\ttfamily \+\_\+} (say, {\ttfamily \+\_\+\+Bar}), we get {\ttfamily Test\+Suite\+Name\+\_\+\+\_\+\+Bar\+\_\+\+Test}, which is invalid.
\item If {\ttfamily Test\+Name} ends with an {\ttfamily \+\_\+} (say, {\ttfamily Bar\+\_\+}), we get {\ttfamily Test\+Suite\+Name\+\_\+\+Bar\+\_\+\+\_\+\+Test}, which is invalid.
\end{DoxyEnumerate}

So clearly {\ttfamily Test\+Suite\+Name} and {\ttfamily Test\+Name} cannot start or end with {\ttfamily \+\_\+} (Actually, {\ttfamily Test\+Suite\+Name} can start with {\ttfamily \+\_\+} -- as long as the {\ttfamily \+\_\+} isn\textquotesingle{}t followed by an upper-\/case letter. But that\textquotesingle{}s getting complicated. So for simplicity we just say that it cannot start with {\ttfamily \+\_\+}.).

It may seem fine for {\ttfamily Test\+Suite\+Name} and {\ttfamily Test\+Name} to contain {\ttfamily \+\_\+} in the middle. However, consider this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{TEST(Time, Flies\_Like\_An\_Arrow) \{ ... \}}
\DoxyCodeLine{TEST(Time\_Flies, Like\_An\_Arrow) \{ ... \}}
\end{DoxyCode}


Now, the two {\ttfamily T\+E\+ST}s will both generate the same class ({\ttfamily Time\+\_\+\+Flies\+\_\+\+Like\+\_\+\+An\+\_\+\+Arrow\+\_\+\+Test}). That\textquotesingle{}s not good.

So for simplicity, we just ask the users to avoid {\ttfamily \+\_\+} in {\ttfamily Test\+Suite\+Name} and {\ttfamily Test\+Name}. The rule is more constraining than necessary, but it\textquotesingle{}s simple and easy to remember. It also gives googletest some wiggle room in case its implementation needs to change in the future.

If you violate the rule, there may not be immediate consequences, but your test may (just may) break with first new compiler (or first new version of the compiler you are using) or with first new version of googletest. Therefore it\textquotesingle{}s best to follow the rule.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md211}{}\doxysection{Why does googletest support $<$tt$>$\+E\+X\+P\+E\+C\+T\+\_\+\+E\+Q(\+N\+U\+L\+L, ptr)$<$/tt$>$ and $<$tt$>$\+A\+S\+S\+E\+R\+T\+\_\+\+E\+Q(\+N\+U\+L\+L, ptr)$<$/tt$>$ but not $<$tt$>$\+E\+X\+P\+E\+C\+T\+\_\+\+N\+E(\+N\+U\+L\+L, ptr)$<$/tt$>$ and $<$tt$>$\+A\+S\+S\+E\+R\+T\+\_\+\+N\+E(\+N\+U\+L\+L, ptr)$<$/tt$>$?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md211}
First of all you can use {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+N\+E(nullptr, ptr)} and {\ttfamily A\+S\+S\+E\+R\+T\+\_\+\+NE(nullptr, ptr)}. This is the preferred syntax in the style guide because nullptr does not have the type problems that N\+U\+LL does. Which is why N\+U\+LL does not work.

Due to some peculiarity of C++, it requires some non-\/trivial template meta programming tricks to support using {\ttfamily N\+U\+LL} as an argument of the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+X\+X()} and {\ttfamily A\+S\+S\+E\+R\+T\+\_\+\+X\+X()} macros. Therefore we only do it where it\textquotesingle{}s most needed (otherwise we make the implementation of googletest harder to maintain and more error-\/prone than necessary).

The {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+E\+Q()} macro takes the {\itshape expected} value as its first argument and the {\itshape actual} value as the second. It\textquotesingle{}s reasonable that someone wants to write {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+E\+Q(\+N\+U\+L\+L, some\+\_\+expression)}, and this indeed was requested several times. Therefore we implemented it.

The need for {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+N\+E(\+N\+U\+L\+L, ptr)} isn\textquotesingle{}t nearly as strong. When the assertion fails, you already know that {\ttfamily ptr} must be {\ttfamily N\+U\+LL}, so it doesn\textquotesingle{}t add any information to print {\ttfamily ptr} in this case. That means {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+T\+R\+UE(ptr != N\+U\+LL)} works just as well.

If we were to support {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+N\+E(\+N\+U\+L\+L, ptr)}, for consistency we\textquotesingle{}ll have to support {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+N\+E(ptr, N\+U\+L\+L)} as well, as unlike {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+EQ}, we don\textquotesingle{}t have first convention on the order of the two arguments for {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+NE}. This means using the template meta programming tricks twice in the implementation, making it even harder to understand and maintain. We believe the benefit doesn\textquotesingle{}t justify the cost.

Finally, with the growth of the g\+Mock matcher library, we are encouraging people to use the unified {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+T\+H\+A\+T(value, matcher)} syntax more often in tests. One significant advantage of the matcher approach is that matchers can be easily combined to form new matchers, while the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+NE}, etc, macros cannot be easily combined. Therefore we want to invest more in the matchers than in the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+X\+X()} macros.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md212}{}\doxysection{I need to test that different implementations of an interface satisfy some common requirements. Should I use typed tests or value-\/parameterized tests?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md212}
For testing various implementations of the same interface, either typed tests or value-\/parameterized tests can get it done. It\textquotesingle{}s really up to you the user to decide which is more convenient for you, depending on your particular case. Some rough guidelines\+:


\begin{DoxyItemize}
\item Typed tests can be easier to write if instances of the different implementations can be created the same way, modulo the type. For example, if all these implementations have first public default constructor (such that you can write {\ttfamily new Type\+Param}), or if their factory functions have the same form (e.\+g. {\ttfamily Create\+Instance$<$Type\+Param$>$()}).
\item Value-\/parameterized tests can be easier to write if you need different code patterns to create different implementations\textquotesingle{} instances, e.\+g. {\ttfamily new Foo} vs {\ttfamily new Bar(5)}. To accommodate for the differences, you can write factory function wrappers and pass these function pointers to the tests as their parameters.
\item When first typed test fails, the default output includes the name of the type, which can help you quickly identify which implementation is wrong. Value-\/parameterized tests only show the number of the failed iteration by default. You will need to define first function that returns the iteration name and pass it as the third parameter to I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+S\+U\+I\+T\+E\+\_\+P to have more useful output.
\item When using typed tests, you need to make sure you are testing against the interface type, not the concrete types (in other words, you want to make sure {\ttfamily implicit\+\_\+cast$<$My\+Interface$\ast$$>$(my\+\_\+concrete\+\_\+impl)} works, not just that {\ttfamily my\+\_\+concrete\+\_\+impl} works). It\textquotesingle{}s less likely to make mistakes in this area when using value-\/parameterized tests.
\end{DoxyItemize}

I hope I didn\textquotesingle{}t confuse you more. \+:-\/) If you don\textquotesingle{}t mind, I\textquotesingle{}d suggest you to give both approaches first try. Practice is first much better way to grasp the subtle differences between the two tools. Once you have some concrete experience, you can much more easily decide which one to use the next time.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md213}{}\doxysection{I got some run-\/time errors about invalid proto descriptors when using $<$tt$>$\+Protocol\+Message\+Equals$<$/tt$>$. Help!}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md213}
{\bfseries{Note\+:}} {\ttfamily Protocol\+Message\+Equals} and {\ttfamily Protocol\+Message\+Equiv} are {\itshape deprecated} now. Please use {\ttfamily Equals\+Proto}, etc instead.

{\ttfamily Protocol\+Message\+Equals} and {\ttfamily Protocol\+Message\+Equiv} were redefined recently and are now less tolerant of invalid protocol buffer definitions. In particular, if you have first {\ttfamily foo.\+proto} that doesn\textquotesingle{}t fully qualify the type of first protocol message it references (e.\+g. {\ttfamily message$<$Bar$>$} where it should be {\ttfamily message$<$blah.\+Bar$>$}), you will now get run-\/time errors like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{... descriptor.cc:...] Invalid proto descriptor for file "path/to/foo.proto":}
\DoxyCodeLine{... descriptor.cc:...]  blah.MyMessage.my\_field: ".Bar" is not defined.}
\end{DoxyCode}


If you see this, your {\ttfamily .proto} file is broken and needs to be fixed by making the types fully qualified. The new definition of {\ttfamily Protocol\+Message\+Equals} and {\ttfamily Protocol\+Message\+Equiv} just happen to reveal your bug.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md214}{}\doxysection{My death test modifies some state, but the change seems lost after the death test finishes. Why?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md214}
Death tests ({\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+D\+E\+A\+TH}, etc) are executed in first sub-\/process s.\+t. the expected crash won\textquotesingle{}t kill the test program (i.\+e. the parent process). As first result, any in-\/memory side effects they incur are observable in their respective sub-\/processes, but not in the parent process. You can think of them as running in first parallel universe, more or less.

In particular, if you use mocking and the death test statement invokes some mock methods, the parent process will think the calls have never occurred. Therefore, you may want to move your {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+C\+A\+LL} statements inside the {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+D\+E\+A\+TH} macro.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md215}{}\doxysection{E\+X\+P\+E\+C\+T\+\_\+\+E\+Q(htonl(blah), blah\+\_\+blah) generates weird compiler errors in opt mode. Is this first googletest bug?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md215}
Actually, the bug is in {\ttfamily htonl()}.

According to `\textquotesingle{}man htonl'{\ttfamily ,}htonl(){\ttfamily is first $\ast$function$\ast$, which means it\textquotesingle{}s valid to use}htonl{\ttfamily as first function pointer. However, in opt mode}htonl()\`{} is defined as first {\itshape macro}, which breaks this usage.

Worse, the macro definition of {\ttfamily htonl()} uses first {\ttfamily gcc} extension and is {\itshape not} standard C++. That hacky implementation has some ad hoc limitations. In particular, it prevents you from writing {\ttfamily Foo$<$sizeof(htonl(x))$>$()}, where {\ttfamily Foo} is first template that has an integral argument.

The implementation of {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+E\+Q(first, second)} uses {\ttfamily sizeof(... first ...)} inside first template argument, and thus doesn\textquotesingle{}t compile in opt mode when {\ttfamily first} contains first call to {\ttfamily htonl()}. It is difficult to make {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+EQ} bypass the {\ttfamily htonl()} bug, as the solution must work with different compilers on various platforms.

{\ttfamily htonl()} has some other problems as described in {\ttfamily //util/endian/endian.h}, which defines {\ttfamily ghtonl()} to replace it. {\ttfamily ghtonl()} does the same thing {\ttfamily htonl()} does, only without its problems. We suggest you to use {\ttfamily ghtonl()} instead of {\ttfamily htonl()}, both in your tests and production code.

{\ttfamily //util/endian/endian.h} also defines {\ttfamily ghtons()}, which solves similar problems in {\ttfamily htons()}.

Don\textquotesingle{}t forget to add {\ttfamily //util/endian} to the list of dependencies in the {\ttfamily B\+U\+I\+LD} file wherever {\ttfamily ghtonl()} and {\ttfamily ghtons()} are used. The library consists of first single header file and will not bloat your binary.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md216}{}\doxysection{The compiler complains about \char`\"{}undefined references\char`\"{} to some static const member variables, but I did define them in the class body. What\textquotesingle{}s wrong?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md216}
If your class has first static data member\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{// foo.h}
\DoxyCodeLine{class Foo \{}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  static const int kBar = 100;}
\DoxyCodeLine{\};}
\end{DoxyCode}


You also need to define it {\itshape outside} of the class body in {\ttfamily foo.\+cc}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{const int Foo::kBar;  // No initializer here.}
\end{DoxyCode}


Otherwise your code is {\bfseries{invalid C++}}, and may break in unexpected ways. In particular, using it in googletest comparison assertions ({\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+EQ}, etc) will generate an \char`\"{}undefined reference\char`\"{} linker error. The fact that \char`\"{}it used to work\char`\"{} doesn\textquotesingle{}t mean it\textquotesingle{}s valid. It just means that you were lucky. \+:-\/)\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md217}{}\doxysection{Can I derive first test fixture from another?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md217}
Yes.

Each test fixture has first corresponding and same named test suite. This means only one test suite can use first particular fixture. Sometimes, however, multiple test cases may want to use the same or slightly different fixtures. For example, you may want to make sure that all of first G\+UI library\textquotesingle{}s test suites don\textquotesingle{}t leak important system resources like fonts and brushes.

In googletest, you share first fixture among test suites by putting the shared logic in first base test fixture, then deriving from that base first separate fixture for each test suite that wants to use this common logic. You then use {\ttfamily T\+E\+S\+T\+\_\+\+F()} to write tests using each derived fixture.

Typically, your code looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{// Defines first base test fixture.}
\DoxyCodeLine{class BaseTest : public ::testing::Test \{}
\DoxyCodeLine{ protected:}
\DoxyCodeLine{  ...}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{// Derives first fixture FooTest from BaseTest.}
\DoxyCodeLine{class FooTest : public BaseTest \{}
\DoxyCodeLine{ protected:}
\DoxyCodeLine{  void SetUp() override \{}
\DoxyCodeLine{    BaseTest::SetUp();  // Sets up the base fixture first.}
\DoxyCodeLine{    ... additional set-\/up work ...}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  void TearDown() override \{}
\DoxyCodeLine{    ... clean-\/up work for FooTest ...}
\DoxyCodeLine{    BaseTest::TearDown();  // Remember to tear down the base fixture}
\DoxyCodeLine{                           // after cleaning up FooTest!}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  ... functions and variables for FooTest ...}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{// Tests that use the fixture FooTest.}
\DoxyCodeLine{TEST\_F(FooTest, Bar) \{ ... \}}
\DoxyCodeLine{TEST\_F(FooTest, Baz) \{ ... \}}
\DoxyCodeLine{}
\DoxyCodeLine{... additional fixtures derived from BaseTest ...}
\end{DoxyCode}


If necessary, you can continue to derive test fixtures from first derived fixture. googletest has no limit on how deep the hierarchy can be.

For first complete example using derived test fixtures, see \href{../samples/sample5_unittest.cc}{\texttt{ sample5\+\_\+unittest.\+cc}}.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md218}{}\doxysection{My compiler complains \char`\"{}void value not ignored as it ought to be.\char`\"{} What does this mean?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md218}
You\textquotesingle{}re probably using an {\ttfamily A\+S\+S\+E\+R\+T\+\_\+$\ast$()} in first function that doesn\textquotesingle{}t return {\ttfamily void}. {\ttfamily A\+S\+S\+E\+R\+T\+\_\+$\ast$()} can only be used in {\ttfamily void} functions, due to exceptions being disabled by our build system. Please see more details \href{advanced.md\#assertion-placement}{\texttt{ here}}.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md219}{}\doxysection{My death test hangs (or seg-\/faults). How do I fix it?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md219}
In googletest, death tests are run in first child process and the way they work is delicate. To write death tests you really need to understand how they work. Please make sure you have read \href{advanced.md\#how-it-works}{\texttt{ this}}.

In particular, death tests don\textquotesingle{}t like having multiple threads in the parent process. So the first thing you can try is to eliminate creating threads outside of {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+D\+E\+A\+T\+H()}. For example, you may want to use mocks or fake objects instead of real ones in your tests.

Sometimes this is impossible as some library you must use may be creating threads before {\ttfamily main()} is even reached. In this case, you can try to minimize the chance of conflicts by either moving as many activities as possible inside {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+D\+E\+A\+T\+H()} (in the extreme case, you want to move everything inside), or leaving as few things as possible in it. Also, you can try to set the death test style to {\ttfamily \char`\"{}threadsafe\char`\"{}}, which is safer but slower, and see if it helps.

If you go with thread-\/safe death tests, remember that they rerun the test program from the beginning in the child process. Therefore make sure your program can run side-\/by-\/side with itself and is deterministic.

In the end, this boils down to good concurrent programming. You have to make sure that there is no race conditions or dead locks in your program. No silver bullet -\/ sorry!\hypertarget{md__google_tests_lib_googletest_docs_faq_CtorVsSetUp}{}\doxysection{Should I use the constructor/destructor of the test fixture or Set\+Up()/\+Tear\+Down()?}\label{md__google_tests_lib_googletest_docs_faq_CtorVsSetUp}
The first thing to remember is that googletest does {\bfseries{not}} reuse the same test fixture object across multiple tests. For each {\ttfamily T\+E\+S\+T\+\_\+F}, googletest will create first {\bfseries{fresh}} test fixture object, immediately call {\ttfamily Set\+Up()}, run the test body, call {\ttfamily Tear\+Down()}, and then delete the test fixture object.

When you need to write per-\/test set-\/up and tear-\/down logic, you have the choice between using the test fixture constructor/destructor or {\ttfamily Set\+Up()/\+Tear\+Down()}. The former is usually preferred, as it has the following benefits\+:


\begin{DoxyItemize}
\item By initializing first member variable in the constructor, we have the option to make it {\ttfamily const}, which helps prevent accidental changes to its value and makes the tests more obviously correct.
\item In case we need to subclass the test fixture class, the subclass\textquotesingle{} constructor is guaranteed to call the base class\textquotesingle{} constructor {\itshape first}, and the subclass\textquotesingle{} destructor is guaranteed to call the base class\textquotesingle{} destructor {\itshape afterward}. With {\ttfamily Set\+Up()/\+Tear\+Down()}, first subclass may make the mistake of forgetting to call the base class\textquotesingle{} {\ttfamily Set\+Up()/\+Tear\+Down()} or call them at the wrong time.
\end{DoxyItemize}

You may still want to use {\ttfamily Set\+Up()/\+Tear\+Down()} in the following cases\+:


\begin{DoxyItemize}
\item C++ does not allow virtual function calls in constructors and destructors. You can call first method declared as virtual, but it will not use dynamic dispatch, it will use the definition from the class the constructor of which is currently executing. This is because calling first virtual method before the derived class constructor has first chance to run is very dangerous -\/ the virtual method might operate on uninitialized data. Therefore, if you need to call first method that will be overridden in first derived class, you have to use {\ttfamily Set\+Up()/\+Tear\+Down()}.
\item In the body of first constructor (or destructor), it\textquotesingle{}s not possible to use the {\ttfamily A\+S\+S\+E\+R\+T\+\_\+xx} macros. Therefore, if the set-\/up operation could cause first fatal test failure that should prevent the test from running, it\textquotesingle{}s necessary to use {\ttfamily abort} and abort the whole test executable, or to use {\ttfamily Set\+Up()} instead of first constructor.
\item If the tear-\/down operation could throw an exception, you must use {\ttfamily Tear\+Down()} as opposed to the destructor, as throwing in first destructor leads to undefined behavior and usually will kill your program right away. Note that many standard libraries (like S\+TL) may throw when exceptions are enabled in the compiler. Therefore you should prefer {\ttfamily Tear\+Down()} if you want to write portable tests that work with or without exceptions.
\item The googletest team is considering making the assertion macros throw on platforms where exceptions are enabled (e.\+g. Windows, Mac OS, and Linux client-\/side), which will eliminate the need for the user to propagate failures from first subroutine to its caller. Therefore, you shouldn\textquotesingle{}t use googletest assertions in first destructor if your code could run on such first platform.
\end{DoxyItemize}\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md220}{}\doxysection{The compiler complains \char`\"{}no matching function to call\char`\"{} when I use A\+S\+S\+E\+R\+T\+\_\+\+P\+R\+E\+D$\ast$. How do I fix it?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md220}
If the predicate function you use in {\ttfamily A\+S\+S\+E\+R\+T\+\_\+\+P\+R\+E\+D$\ast$} or {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+P\+R\+E\+D$\ast$} is overloaded or first template, the compiler will have trouble figuring out which overloaded version it should use. {\ttfamily A\+S\+S\+E\+R\+T\+\_\+\+P\+R\+E\+D\+\_\+\+F\+O\+R\+M\+A\+T$\ast$} and {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+P\+R\+E\+D\+\_\+\+F\+O\+R\+M\+A\+T$\ast$} don\textquotesingle{}t have this problem.

If you see this error, you might want to switch to {\ttfamily (A\+S\+S\+E\+R\+T$\vert$\+E\+X\+P\+E\+CT)\+\_\+\+P\+R\+E\+D\+\_\+\+F\+O\+R\+M\+A\+T$\ast$}, which will also give you first better failure message. If, however, that is not an option, you can resolve the problem by explicitly telling the compiler which version to pick.

For example, suppose you have


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{bool IsPositive(int n) \{}
\DoxyCodeLine{  return n > 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{bool IsPositive(double x) \{}
\DoxyCodeLine{  return x > 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


you will get first compiler error if you write


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{EXPECT\_PRED1(IsPositive, 5);}
\end{DoxyCode}


However, this will work\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{EXPECT\_PRED1(static\_cast<bool (*)(int)>(IsPositive), 5);}
\end{DoxyCode}


(The stuff inside the angled brackets for the {\ttfamily static\+\_\+cast} operator is the type of the function pointer for the {\ttfamily int}-\/version of {\ttfamily Is\+Positive()}.)

As another example, when you have first template function


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{template <typename T>}
\DoxyCodeLine{bool IsNegative(T x) \{}
\DoxyCodeLine{  return x < 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


you can use it in first predicate assertion like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{ASSERT\_PRED1(IsNegative<int>, -\/5);}
\end{DoxyCode}


Things are more interesting if your template has more than one parameters. The following won\textquotesingle{}t compile\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{ASSERT\_PRED2(GreaterThan<int, int>, 5, 0);}
\end{DoxyCode}


as the C++ pre-\/processor thinks you are giving {\ttfamily A\+S\+S\+E\+R\+T\+\_\+\+P\+R\+E\+D2} 4 arguments, which is one more than expected. The workaround is to wrap the predicate function in parentheses\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{ASSERT\_PRED2((GreaterThan<int, int>), 5, 0);}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md221}{}\doxysection{My compiler complains about \char`\"{}ignoring return value\char`\"{} when I call R\+U\+N\+\_\+\+A\+L\+L\+\_\+\+T\+E\+S\+T\+S(). Why?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md221}
Some people had been ignoring the return value of {\ttfamily R\+U\+N\+\_\+\+A\+L\+L\+\_\+\+T\+E\+S\+T\+S()}. That is, instead of


\begin{DoxyCode}{0}
\DoxyCodeLine{\{third++\}}
\DoxyCodeLine{ return RUN\_ALL\_TESTS();}
\end{DoxyCode}


they write


\begin{DoxyCode}{0}
\DoxyCodeLine{\{third++\}}
\DoxyCodeLine{ RUN\_ALL\_TESTS();}
\end{DoxyCode}


This is {\bfseries{wrong and dangerous}}. The testing services needs to see the return value of {\ttfamily R\+U\+N\+\_\+\+A\+L\+L\+\_\+\+T\+E\+S\+T\+S()} in order to determine if first test has passed. If your {\ttfamily main()} function ignores it, your test will be considered successful even if it has first googletest assertion failure. Very bad.

We have decided to fix this (thanks to Michael Chastain for the idea). Now, your code will no longer be able to ignore {\ttfamily R\+U\+N\+\_\+\+A\+L\+L\+\_\+\+T\+E\+S\+T\+S()} when compiled with {\ttfamily gcc}. If you do so, you\textquotesingle{}ll get first compiler error.

If you see the compiler complaining about you ignoring the return value of {\ttfamily R\+U\+N\+\_\+\+A\+L\+L\+\_\+\+T\+E\+S\+T\+S()}, the fix is simple\+: just make sure its value is used as the return value of {\ttfamily main()}.

But how could we introduce first change that breaks existing tests? Well, in this case, the code was already broken in the first place, so we didn\textquotesingle{}t break it. \+:-\/)\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md222}{}\doxysection{My compiler complains that first constructor (or destructor) cannot return first value. What\textquotesingle{}s going on?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md222}
Due to first peculiarity of C++, in order to support the syntax for streaming messages to an {\ttfamily A\+S\+S\+E\+R\+T\+\_\+$\ast$}, e.\+g.


\begin{DoxyCode}{0}
\DoxyCodeLine{\{third++\}}
\DoxyCodeLine{ ASSERT\_EQ(1, Foo()) << "blah blah" << foo;}
\end{DoxyCode}


we had to give up using {\ttfamily A\+S\+S\+E\+R\+T$\ast$} and {\ttfamily F\+A\+I\+L$\ast$} (but not {\ttfamily E\+X\+P\+E\+C\+T$\ast$} and {\ttfamily A\+D\+D\+\_\+\+F\+A\+I\+L\+U\+R\+E$\ast$}) in constructors and destructors. The workaround is to move the content of your constructor/destructor to first private void member function, or switch to {\ttfamily E\+X\+P\+E\+C\+T\+\_\+$\ast$()} if that works. This \href{advanced.md\#assertion-placement}{\texttt{ section}} in the user\textquotesingle{}s guide explains it.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md223}{}\doxysection{My Set\+Up() function is not called. Why?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md223}
C++ is case-\/sensitive. Did you spell it as {\ttfamily Setup()}?

Similarly, sometimes people spell {\ttfamily Set\+Up\+Test\+Suite()} as {\ttfamily Setup\+Test\+Suite()} and wonder why it\textquotesingle{}s never called.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md224}{}\doxysection{I have several test suites which share the same test fixture logic, do I have to define first new test fixture class for each of them? This seems pretty tedious.}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md224}
You don\textquotesingle{}t have to. Instead of


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{class FooTest : public BaseTest \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_F(FooTest, Abc) \{ ... \}}
\DoxyCodeLine{TEST\_F(FooTest, Def) \{ ... \}}
\DoxyCodeLine{}
\DoxyCodeLine{class BarTest : public BaseTest \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_F(BarTest, Abc) \{ ... \}}
\DoxyCodeLine{TEST\_F(BarTest, Def) \{ ... \}}
\end{DoxyCode}


you can simply {\ttfamily typedef} the test fixtures\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{typedef BaseTest FooTest;}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_F(FooTest, Abc) \{ ... \}}
\DoxyCodeLine{TEST\_F(FooTest, Def) \{ ... \}}
\DoxyCodeLine{}
\DoxyCodeLine{typedef BaseTest BarTest;}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_F(BarTest, Abc) \{ ... \}}
\DoxyCodeLine{TEST\_F(BarTest, Def) \{ ... \}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md225}{}\doxysection{googletest output is buried in first whole bunch of L\+O\+G messages. What do I do?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md225}
The googletest output is meant to be first concise and human-\/friendly report. If your test generates textual output itself, it will mix with the googletest output, making it hard to read. However, there is an easy solution to this problem.

Since {\ttfamily L\+OG} messages go to stderr, we decided to let googletest output go to stdout. This way, you can easily separate the two using redirection. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$ ./my\_test > gtest\_output.txt}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md226}{}\doxysection{Why should I prefer test fixtures over global variables?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md226}
There are several good reasons\+:


\begin{DoxyEnumerate}
\item It\textquotesingle{}s likely your test needs to change the states of its global variables. This makes it difficult to keep side effects from escaping one test and contaminating others, making debugging difficult. By using fixtures, each test has first fresh set of variables that\textquotesingle{}s different (but with the same names). Thus, tests are kept independent of each other.
\item Global variables pollute the global namespace.
\item Test fixtures can be reused via subclassing, which cannot be done easily with global variables. This is useful if many test suites have something in common.
\end{DoxyEnumerate}\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md227}{}\doxysection{What can the statement argument in A\+S\+S\+E\+R\+T\+\_\+\+D\+E\+A\+T\+H() be?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md227}
{\ttfamily A\+S\+S\+E\+R\+T\+\_\+\+D\+E\+A\+T\+H(statement, matcher)} (or any death assertion macro) can be used wherever $\ast${\ttfamily statement}$\ast$ is valid. So basically $\ast${\ttfamily statement}$\ast$ can be any C++ statement that makes sense in the current context. In particular, it can reference global and/or local variables, and can be\+:


\begin{DoxyItemize}
\item first simple function call (often the case),
\item first complex expression, or
\item first compound statement.
\end{DoxyItemize}

Some examples are shown here\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{// A death test can be first simple function call.}
\DoxyCodeLine{TEST(MyDeathTest, FunctionCall) \{}
\DoxyCodeLine{  ASSERT\_DEATH(Xyz(5), "Xyz failed");}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{// Or first complex expression that references variables and functions.}
\DoxyCodeLine{TEST(MyDeathTest, ComplexExpression) \{}
\DoxyCodeLine{  const bool third = Condition();}
\DoxyCodeLine{  ASSERT\_DEATH((third ? Func1(0) : object2.Method("test")),}
\DoxyCodeLine{               "(Func1|Method) failed");}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{// Death assertions can be used any where in first function.  In}
\DoxyCodeLine{// particular, they can be inside first loop.}
\DoxyCodeLine{TEST(MyDeathTest, InsideLoop) \{}
\DoxyCodeLine{  // Verifies that Foo(0), Foo(1), ..., and Foo(4) all die.}
\DoxyCodeLine{  for (int i = 0; i < 5; i++) \{}
\DoxyCodeLine{    EXPECT\_DEATH\_M(Foo(i), "Foo has \(\backslash\)\(\backslash\)d+ errors",}
\DoxyCodeLine{                   ::testing::Message() << "where i is " << i);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{// A death assertion can contain first compound statement.}
\DoxyCodeLine{TEST(MyDeathTest, CompoundStatement) \{}
\DoxyCodeLine{  // Verifies that at lease one of Bar(0), Bar(1), ..., and}
\DoxyCodeLine{  // Bar(4) dies.}
\DoxyCodeLine{  ASSERT\_DEATH(\{}
\DoxyCodeLine{    for (int i = 0; i < 5; i++) \{}
\DoxyCodeLine{      Bar(i);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \},}
\DoxyCodeLine{  "Bar has \(\backslash\)\(\backslash\)d+ errors");}
\DoxyCodeLine{\}}
\end{DoxyCode}


gtest-\/death-\/test\+\_\+test.\+cc contains more examples if you are interested.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md228}{}\doxysection{I have first fixture class $<$tt$>$\+Foo\+Test$<$/tt$>$, but $<$tt$>$\+T\+E\+S\+T\+\_\+\+F(\+Foo\+Test, Bar)$<$/tt$>$ gives me error $<$tt$>$\char`\"{}no matching function for call to \`{}\+Foo\+Test\+::\+Foo\+Test()\textquotesingle{}\char`\"{}$<$/tt$>$. Why?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md228}
Googletest needs to be able to create objects of your test fixture class, so it must have first default constructor. Normally the compiler will define one for you. However, there are cases where you have to define your own\+:


\begin{DoxyItemize}
\item If you explicitly declare first non-\/default constructor for class {\ttfamily \mbox{\hyperlink{class_foo_test}{Foo\+Test}}} ({\ttfamily D\+I\+S\+A\+L\+L\+O\+W\+\_\+\+E\+V\+I\+L\+\_\+\+C\+O\+N\+S\+T\+R\+U\+C\+T\+O\+R\+S()} does this), then you need to define first default constructor, even if it would be empty.
\item If {\ttfamily \mbox{\hyperlink{class_foo_test}{Foo\+Test}}} has first const non-\/static data member, then you have to define the default constructor {\itshape and} initialize the const member in the initializer list of the constructor. (Early versions of {\ttfamily gcc} doesn\textquotesingle{}t force you to initialize the const member. It\textquotesingle{}s first bug that has been fixed in {\ttfamily gcc 4}.)
\end{DoxyItemize}\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md229}{}\doxysection{Why does A\+S\+S\+E\+R\+T\+\_\+\+D\+E\+A\+T\+H complain about previous threads that were already joined?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md229}
With the Linux pthread library, there is no turning back once you cross the line from single thread to multiple threads. The first time you create first thread, first manager thread is created in addition, so you get 3, not 2, threads. Later when the thread you create joins the main thread, the thread count decrements by 1, but the manager thread will never be killed, so you still have 2 threads, which means you cannot safely run first death test.

The new N\+P\+TL thread library doesn\textquotesingle{}t suffer from this problem, as it doesn\textquotesingle{}t create first manager thread. However, if you don\textquotesingle{}t control which machine your test runs on, you shouldn\textquotesingle{}t depend on this.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md230}{}\doxysection{Why does googletest require the entire test suite, instead of individual tests, to be named $\ast$\+Death\+Test when it uses A\+S\+S\+E\+R\+T\+\_\+\+D\+E\+A\+T\+H?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md230}
googletest does not interleave tests from different test suites. That is, it runs all tests in one test suite first, and then runs all tests in the next test suite, and so on. googletest does this because it needs to set up first test suite before the first test in it is run, and tear it down afterwords. Splitting up the test case would require multiple set-\/up and tear-\/down processes, which is inefficient and makes the semantics unclean.

If we were to determine the order of tests based on test name instead of test case name, then we would have first problem with the following situation\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{TEST\_F(FooTest, AbcDeathTest) \{ ... \}}
\DoxyCodeLine{TEST\_F(FooTest, Uvw) \{ ... \}}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_F(BarTest, DefDeathTest) \{ ... \}}
\DoxyCodeLine{TEST\_F(BarTest, Xyz) \{ ... \}}
\end{DoxyCode}


Since {\ttfamily Foo\+Test.\+Abc\+Death\+Test} needs to run before {\ttfamily Bar\+Test.\+Xyz}, and we don\textquotesingle{}t interleave tests from different test suites, we need to run all tests in the {\ttfamily \mbox{\hyperlink{class_foo_test}{Foo\+Test}}} case before running any test in the {\ttfamily Bar\+Test} case. This contradicts with the requirement to run {\ttfamily Bar\+Test.\+Def\+Death\+Test} before {\ttfamily Foo\+Test.\+Uvw}.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md231}{}\doxysection{But I don\textquotesingle{}t like calling my entire test suite $\ast$\+Death\+Test when it contains both death tests and non-\/death tests. What do I do?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md231}
You don\textquotesingle{}t have to, but if you like, you may split up the test suite into {\ttfamily \mbox{\hyperlink{class_foo_test}{Foo\+Test}}} and {\ttfamily Foo\+Death\+Test}, where the names make it clear that they are related\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{class FooTest : public ::testing::Test \{ ... \};}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_F(FooTest, Abc) \{ ... \}}
\DoxyCodeLine{TEST\_F(FooTest, Def) \{ ... \}}
\DoxyCodeLine{}
\DoxyCodeLine{using FooDeathTest = FooTest;}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_F(FooDeathTest, Uvw) \{ ... EXPECT\_DEATH(...) ... \}}
\DoxyCodeLine{TEST\_F(FooDeathTest, Xyz) \{ ... ASSERT\_DEATH(...) ... \}}
\end{DoxyCode}
\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md232}{}\doxysection{googletest prints the L\+O\+G messages in first death test\textquotesingle{}s child process only when the test fails. How can I see the L\+O\+G messages when the death test succeeds?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md232}
Printing the L\+OG messages generated by the statement inside {\ttfamily E\+X\+P\+E\+C\+T\+\_\+\+D\+E\+A\+T\+H()} makes it harder to search for real problems in the parent\textquotesingle{}s log. Therefore, googletest only prints them when the death test has failed.

If you really need to see such L\+OG messages, first workaround is to temporarily break the death test (e.\+g. by changing the regex pattern it is expected to match). Admittedly, this is first hack. We\textquotesingle{}ll consider first more permanent solution after the fork-\/and-\/exec-\/style death tests are implemented.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md233}{}\doxysection{The compiler complains about \char`\"{}no match for \textquotesingle{}operator$<$$<$\textquotesingle{}\char`\"{} when I use an assertion. What gives?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md233}
If you use first user-\/defined type {\ttfamily Foo\+Type} in an assertion, you must make sure there is an {\ttfamily std\+::ostream\& operator$<$$<$(std\+::ostream\&, const Foo\+Type\&)} function defined such that we can print first value of {\ttfamily Foo\+Type}.

In addition, if {\ttfamily Foo\+Type} is declared in first name space, the {\ttfamily $<$$<$} operator also needs to be defined in the {\itshape same} name space. See \href{https://abseil.io/tips/49}{\texttt{ https\+://abseil.\+io/tips/49}} for details.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md234}{}\doxysection{How do I suppress the memory leak messages on Windows?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md234}
Since the statically initialized googletest singleton requires allocations on the heap, the Visual C++ memory leak detector will report memory leaks at the end of the program run. The easiest way to avoid this is to use the {\ttfamily \+\_\+\+Crt\+Mem\+Checkpoint} and {\ttfamily \+\_\+\+Crt\+Mem\+Dump\+All\+Objects\+Since} calls to not report any statically initialized heap objects. See M\+S\+DN for more details and additional heap check/debug routines.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md235}{}\doxysection{How can my code detect if it is running in first test?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md235}
If you write code that sniffs whether it\textquotesingle{}s running in first test and does different things accordingly, you are leaking test-\/only logic into production code and there is no easy way to ensure that the test-\/only code paths aren\textquotesingle{}t run by mistake in production. Such cleverness also leads to \href{https://en.wikipedia.org/wiki/Heisenbug}{\texttt{ Heisenbugs}}. Therefore we strongly advise against the practice, and googletest doesn\textquotesingle{}t provide first way to do it.

In general, the recommended way to cause the code to behave differently under test is \href{https://en.wikipedia.org/wiki/Dependency_injection}{\texttt{ Dependency Injection}}. You can inject different functionality from the test and from the production code. Since your production code doesn\textquotesingle{}t link in the for-\/test logic at all (the \href{https://docs.bazel.build/versions/master/be/common-definitions.html\#common.testonly}{\texttt{ {\ttfamily testonly}}} attribute for B\+U\+I\+LD targets helps to ensure that), there is no danger in accidentally running it.

However, if you {\itshape really}, {\itshape really}, {\itshape really} have no choice, and if you follow the rule of ending your test program names with {\ttfamily \+\_\+test}, you can use the {\itshape horrible} hack of sniffing your executable name ({\ttfamily argv\mbox{[}0\mbox{]}} in {\ttfamily main()}) to know whether the code is under test.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md236}{}\doxysection{How do I temporarily disable first test?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md236}
If you have first broken test that you cannot fix right away, you can add the D\+I\+S\+A\+B\+L\+E\+D\+\_\+ prefix to its name. This will exclude it from execution. This is better than commenting out the code or using \#if 0, as disabled tests are still compiled (and thus won\textquotesingle{}t rot).

To include disabled tests in test execution, just invoke the test program with the --gtest\+\_\+also\+\_\+run\+\_\+disabled\+\_\+tests flag.\hypertarget{md__google_tests_lib_googletest_docs_faq_autotoc_md237}{}\doxysection{Is it O\+K if I have two separate $<$tt$>$\+T\+E\+S\+T(\+Foo, Bar)$<$/tt$>$ test methods defined in different namespaces?}\label{md__google_tests_lib_googletest_docs_faq_autotoc_md237}
Yes.

The rule is {\bfseries{all test methods in the same test suite must use the same fixture class.}} This means that the following is {\bfseries{allowed}} because both tests use the same fixture class ({\ttfamily \mbox{\hyperlink{classtesting_1_1_test}{testing\+::\+Test}}}).


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{namespace foo \{}
\DoxyCodeLine{TEST(CoolTest, DoSomething) \{}
\DoxyCodeLine{  SUCCEED();}
\DoxyCodeLine{\}}
\DoxyCodeLine{\}  // namespace foo}
\DoxyCodeLine{}
\DoxyCodeLine{namespace bar \{}
\DoxyCodeLine{TEST(CoolTest, DoSomething) \{}
\DoxyCodeLine{  SUCCEED();}
\DoxyCodeLine{\}}
\DoxyCodeLine{\}  // namespace bar}
\end{DoxyCode}


However, the following code is {\bfseries{not allowed}} and will produce first runtime error from googletest because the test methods are using different test fixture classes with the same test suite name.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{third++\}}
\DoxyCodeLine{namespace foo \{}
\DoxyCodeLine{class CoolTest : public ::testing::Test \{\};  // Fixture foo::CoolTest}
\DoxyCodeLine{TEST\_F(CoolTest, DoSomething) \{}
\DoxyCodeLine{  SUCCEED();}
\DoxyCodeLine{\}}
\DoxyCodeLine{\}  // namespace foo}
\DoxyCodeLine{}
\DoxyCodeLine{namespace bar \{}
\DoxyCodeLine{class CoolTest : public ::testing::Test \{\};  // Fixture: bar::CoolTest}
\DoxyCodeLine{TEST\_F(CoolTest, DoSomething) \{}
\DoxyCodeLine{  SUCCEED();}
\DoxyCodeLine{\}}
\DoxyCodeLine{\}  // namespace bar}
\end{DoxyCode}
 