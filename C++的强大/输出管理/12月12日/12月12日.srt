1
00:00:00,600 --> 00:00:02,766
好下面我们进入到c i加

2
00:00:02,766 --> 00:00:05,266
面对对象的这个具体内容的学习

3
00:00:05,266 --> 00:00:08,499
首先我们呢要把我们的这个嗯

4
00:00:08,500 --> 00:00:09,666
c i加里面的对象

5
00:00:09,666 --> 00:00:11,933
大致大体的分为两种类型

6
00:00:11,933 --> 00:00:13,199
一个叫做具体类型

7
00:00:13,200 --> 00:00:15,100
一个叫做抽象类型啊

8
00:00:15,466 --> 00:00:17,099
这个我们

9
00:00:17,200 --> 00:00:18,600
这一个视频的话

10
00:00:18,600 --> 00:00:20,766
就是来讲解什么是具体类型

11
00:00:20,766 --> 00:00:22,333
然后我给出了他的

12
00:00:22,400 --> 00:00:24,366
就是书本上给出的一些特点

13
00:00:24,366 --> 00:00:26,266
然后我进行了一些归纳

14
00:00:26,266 --> 00:00:27,499
大家可以看一下

15
00:00:27,766 --> 00:00:29,533
首先是嗯

16
00:00:29,666 --> 00:00:33,299
具体类型是如同内置类型的类型

17
00:00:33,500 --> 00:00:34,600
什么叫内置类型呢

18
00:00:34,600 --> 00:00:36,566
其实我们各个各个语言都有一些

19
00:00:36,566 --> 00:00:38,199
很多都是内置类型啊

20
00:00:38,200 --> 00:00:40,733
比如说我们标准的一些数字类型啊

21
00:00:40,733 --> 00:00:42,999
整形浮点型浮点多少位

22
00:00:43,200 --> 00:00:45,500
32位浮点64位浮点啊

23
00:00:45,500 --> 00:00:47,166
是long还是double啊

24
00:00:47,166 --> 00:00:49,533
以及我们的一些字符类型

25
00:00:49,533 --> 00:00:52,466
这些都是属于啊内置的类型

26
00:00:52,600 --> 00:00:53,400
然后

27
00:00:54,533 --> 00:00:56,266
这里我们就给出一个描述

28
00:00:56,266 --> 00:00:58,199
就是具体类型它是具体的

29
00:00:58,200 --> 00:01:01,400
然后这些基础类型它也是一个具体的

30
00:01:01,400 --> 00:01:03,466
所以说它们两个是很相似的

31
00:01:03,666 --> 00:01:04,733
然后第二点

32
00:01:05,066 --> 00:01:07,999
类型的表示只是其定义的一部分

33
00:01:08,900 --> 00:01:10,400
或者说嗯

34
00:01:10,400 --> 00:01:11,200
这个表示

35
00:01:11,200 --> 00:01:13,666
我们用英语说的话就是representation

36
00:01:13,733 --> 00:01:15,966
然后定义的话就是definition

37
00:01:16,200 --> 00:01:19,566
就是说呃我们的一个类啊

38
00:01:19,566 --> 00:01:20,699
它的一个

39
00:01:21,333 --> 00:01:24,933
定义就是包括它里面的public和provide

40
00:01:24,933 --> 00:01:25,999
还有它的一些

41
00:01:26,166 --> 00:01:28,733
这个成员函数的这些东西啊

42
00:01:28,900 --> 00:01:30,600
是他定义的一部分

43
00:01:30,666 --> 00:01:32,133
为什么要强调这一点呢

44
00:01:32,133 --> 00:01:34,533
其实后面我们讲到抽象类型的时候

45
00:01:34,566 --> 00:01:35,566
会说到啊

46
00:01:35,600 --> 00:01:36,266
那个时候

47
00:01:36,266 --> 00:01:39,399
他的表示就不是定义的一部分啊

48
00:01:39,600 --> 00:01:42,366
我们说具体一点比如说一个vector

49
00:01:42,966 --> 00:01:46,666
就是说一个的一个项链这样子的一

50
00:01:46,666 --> 00:01:48,299
个类型

51
00:01:49,366 --> 00:01:52,166
呃我们会考虑到的就是呃

52
00:01:52,166 --> 00:01:54,566
CR家的这个标准库里面的s

53
00:01:54,566 --> 00:01:55,866
t l里面的Wetter

54
00:01:56,100 --> 00:02:00,333
我们说的这个Wetter指的就是指向其

55
00:02:01,066 --> 00:02:03,499
内部存储的一个指针啊

56
00:02:03,500 --> 00:02:04,733
这个非常的重要

57
00:02:04,733 --> 00:02:07,533
因为我们这里要要说清楚

58
00:02:07,600 --> 00:02:11,533
要再强调一点就是说这个内部存储

59
00:02:12,066 --> 00:02:13,533
什么是一个object呢

60
00:02:13,533 --> 00:02:15,899
object就是一个呃

61
00:02:15,966 --> 00:02:16,766
它在

62
00:02:16,966 --> 00:02:19,466
内存上面有一块开辟了一块空间的

63
00:02:19,466 --> 00:02:20,899
它是有一个呃

64
00:02:21,533 --> 00:02:23,499
有一个具体表示的一个东西

65
00:02:23,500 --> 00:02:25,533
那我们说的这个vector实际上

66
00:02:25,900 --> 00:02:28,333
呃代表的是指向这个

67
00:02:28,400 --> 00:02:30,866
这块内存的一个指针

68
00:02:31,133 --> 00:02:33,699
OK这个就是指向我们

69
00:02:33,733 --> 00:02:35,866
内部对象的一个指针啊

70
00:02:35,933 --> 00:02:38,533
然后它是一个很具体的东西

71
00:02:38,533 --> 00:02:41,099
你的一个呃vector的实力

72
00:02:41,100 --> 00:02:43,466
它必定会有存在这么一个

73
00:02:43,500 --> 00:02:45,533
呃内内存的一个空间

74
00:02:45,533 --> 00:02:48,066
然后它也会必定存在这么一个指针

75
00:02:48,466 --> 00:02:49,733
好第三点

76
00:02:49,733 --> 00:02:52,699
如果我们需要更改具体类型的结构

77
00:02:52,700 --> 00:02:55,566
必须要经过重新的编译啊

78
00:02:55,700 --> 00:02:57,766
这点的话也是可以理解的

79
00:02:57,766 --> 00:02:59,999
就是我们呃

80
00:03:00,533 --> 00:03:03,166
我们去考虑我们的一些数字类型啊

81
00:03:03,266 --> 00:03:04,699
然后我们假如是要定

82
00:03:04,700 --> 00:03:07,966
下面我们要定义一个这个呃

83
00:03:08,066 --> 00:03:12,899
虚数你要去因虚数会有10部和虚部吗

84
00:03:12,900 --> 00:03:14,000
我们学的数学也知道

85
00:03:14,000 --> 00:03:16,333
那如果说我要再给他搞多一个

86
00:03:16,466 --> 00:03:18,999
因为其实数学上有一个叫三元数啊

87
00:03:19,000 --> 00:03:20,200
我们10部虚部的话

88
00:03:20,200 --> 00:03:23,200
相当于可以把虚数理解成一个二元数

89
00:03:23,200 --> 00:03:25,966
假如现在我们想要把这个虚数的范围

90
00:03:26,000 --> 00:03:26,900
啊把它

91
00:03:27,133 --> 00:03:29,366
扩展我们不行不仅考虑虚数

92
00:03:29,366 --> 00:03:30,766
我们考虑多元素

93
00:03:30,766 --> 00:03:33,699
也就是虚数是属于多元素里面的一个

94
00:03:33,933 --> 00:03:36,366
呃就是一个子之类吧

95
00:03:36,366 --> 00:03:37,266
可以这么说

96
00:03:37,333 --> 00:03:38,599
实际上是他

97
00:03:38,933 --> 00:03:40,566
这个范畴里面的一部分

98
00:03:40,566 --> 00:03:42,766
那么如果说我们要去改变

99
00:03:42,766 --> 00:03:44,166
这个具体的类型的话

100
00:03:44,166 --> 00:03:45,566
我们不可能通过

101
00:03:45,700 --> 00:03:47,166
嗯在运行时啊

102
00:03:47,166 --> 00:03:48,066
在运行时

103
00:03:48,066 --> 00:03:51,266
通过对这个须类做一些改造啊

104
00:03:51,533 --> 00:03:53,499
就是对虚数这个类做一些改造

105
00:03:53,500 --> 00:03:55,966
能够让他达到我们想要的目的啊

106
00:03:55,966 --> 00:03:57,666
我们必须得重新编译

107
00:03:57,666 --> 00:03:59,499
定义一个多元素的类型

108
00:03:59,500 --> 00:04:01,200
我们才可以做到这一点

109
00:04:01,300 --> 00:04:01,700
所以说

110
00:04:01,700 --> 00:04:04,100
这是他的第三个很重要的一个特点

111
00:04:05,000 --> 00:04:07,466
第四个就是资源管理对象啊

112
00:04:07,500 --> 00:04:10,266
就是我们比如说刚刚说到这个vector啊

113
00:04:10,966 --> 00:04:13,999
他就是一种这个类就是一种资源表

114
00:04:14,133 --> 00:04:15,466
这个管理对象

115
00:04:15,500 --> 00:04:18,933
然后呃他的这个呃

116
00:04:18,933 --> 00:04:21,799
我们称之为resource handler啊

117
00:04:22,766 --> 00:04:24,066
也算是一种

118
00:04:24,700 --> 00:04:25,566
这个winter

119
00:04:25,700 --> 00:04:26,500
这个stream

120
00:04:27,166 --> 00:04:27,799
这类的

121
00:04:27,800 --> 00:04:30,900
我们是可以控制我们内存里面的这个

122
00:04:31,000 --> 00:04:31,800
呃

123
00:04:32,766 --> 00:04:34,199
分配和销毁的啊

124
00:04:34,200 --> 00:04:36,566
他们也算是一种具体类型

125
00:04:36,566 --> 00:04:37,666
那总体来说

126
00:04:37,800 --> 00:04:39,766
这些东西说的都有点模糊

127
00:04:39,766 --> 00:04:42,366
我们下面来举出一些这个例子

128
00:04:43,366 --> 00:04:45,466
书中给到的第一个例子就是

129
00:04:45,666 --> 00:04:48,566
刚刚说到了这个复数啊

130
00:04:48,900 --> 00:04:51,366
我刚刚说虚数有有有点问题啊

131
00:04:51,366 --> 00:04:54,366
应该说应该说的是复数并不是说虚数

132
00:04:54,366 --> 00:04:55,999
只不过嗯

133
00:04:56,600 --> 00:04:57,300
也可以这么说

134
00:04:57,300 --> 00:04:59,000
就是复数他一定会有虚

135
00:04:59,766 --> 00:05:01,133
十步和虚步吗

136
00:05:01,133 --> 00:05:04,133
啊对他也可能是一个实数

137
00:05:04,133 --> 00:05:05,733
当虚步为0的时候

138
00:05:05,866 --> 00:05:08,266
那我们继续啊

139
00:05:08,466 --> 00:05:10,899
就是具体的

140
00:05:11,066 --> 00:05:12,599
我这里就是说

141
00:05:12,700 --> 00:05:15,100
因为我们这本书的话呢

142
00:05:15,100 --> 00:05:18,866
他是一个呃面向于有变成经验的人啊

143
00:05:18,866 --> 00:05:22,166
所以说我们作为一个编码的一个人

144
00:05:22,166 --> 00:05:23,299
我们会去思考

145
00:05:23,300 --> 00:05:25,966
如果说我们用已知的这个

146
00:05:26,500 --> 00:05:27,200
变成语言

147
00:05:27,200 --> 00:05:29,866
想要去定义这样子的一个复数

148
00:05:30,100 --> 00:05:31,866
我们要给到他一些什么

149
00:05:31,933 --> 00:05:34,333
比如说我现在我知道拍什么

150
00:05:34,366 --> 00:05:35,533
那么我知道

151
00:05:36,166 --> 00:05:38,299
我们一定要给他定义两个属性

152
00:05:38,366 --> 00:05:40,999
就是他的这个十部和虚部对不对

153
00:05:41,300 --> 00:05:42,566
所以说这里啊

154
00:05:42,666 --> 00:05:45,166
这个给到了他的就是这个可

155
00:05:45,400 --> 00:05:46,800
可贝斯这个复述对象

156
00:05:46,800 --> 00:05:48,500
一定会有的这个东西

157
00:05:49,333 --> 00:05:50,666
OK那么我们继续

158
00:05:50,800 --> 00:05:54,333
嗯我们去考虑他会有哪一些方法

159
00:05:54,333 --> 00:05:56,699
他会有计算的那种方法

160
00:05:56,900 --> 00:05:57,766
那首先

161
00:05:57,766 --> 00:06:01,399
返回10步和返回虚步都是属于他的嗯

162
00:06:01,400 --> 00:06:03,166
肯定会有到的方法

163
00:06:03,166 --> 00:06:03,966
还有什么呢

164
00:06:03,966 --> 00:06:04,199
还有

165
00:06:04,200 --> 00:06:06,766
我们会考虑虚数的一些四则运算啊

166
00:06:06,766 --> 00:06:10,266
包括这个嗯加法减法乘法除法

167
00:06:10,366 --> 00:06:11,866
所以说啊

168
00:06:13,133 --> 00:06:15,499
在下面我们这里也有去给到

169
00:06:15,933 --> 00:06:18,866
加法啊其实这个应该叫做自增啊

170
00:06:18,866 --> 00:06:21,066
自增和自减的这个实现

171
00:06:21,566 --> 00:06:22,366
啊

172
00:06:22,366 --> 00:06:24,766
这个和加法是不一不一样的

173
00:06:24,766 --> 00:06:26,499
但是我们的加法的定义

174
00:06:26,500 --> 00:06:29,466
可以依靠于自增和自减的这个实现

175
00:06:30,166 --> 00:06:32,266
然后除了这个之外呢

176
00:06:32,266 --> 00:06:35,133
我们还要去定义最基本最基本的东西

177
00:06:35,133 --> 00:06:38,066
就是说虚数这个类型的构造器

178
00:06:38,066 --> 00:06:39,699
和他的这个销毁器

179
00:06:39,700 --> 00:06:43,266
或者说是他的构造函数和虚构函数啊

180
00:06:43,300 --> 00:06:46,333
这里的话就是在前面给到了这个定义

181
00:06:46,333 --> 00:06:49,133
由于你定义一个复数

182
00:06:49,533 --> 00:06:52,199
你有可能只有这个10步吗

183
00:06:52,200 --> 00:06:53,133
所以说呢

184
00:06:53,266 --> 00:06:55,499
我们需要给到嗯

185
00:06:55,500 --> 00:06:56,733
多种这个实现

186
00:06:58,200 --> 00:07:00,533
这里就就是属于嗯

187
00:07:00,533 --> 00:07:04,699
让他的这个有多种的这个构造函数啊

188
00:07:05,900 --> 00:07:08,600
这个其实到这一块的话

189
00:07:08,600 --> 00:07:12,166
我觉得大家看一看这个语法书啊

190
00:07:12,166 --> 00:07:13,733
其他的应该都能够理解

191
00:07:13,733 --> 00:07:15,466
所以我们去讲到一些需要

192
00:07:15,466 --> 00:07:16,766
注意的一个重点

193
00:07:18,500 --> 00:07:20,733
第一个就是这个CONS的方法

194
00:07:20,733 --> 00:07:22,533
与作用对象的这个

195
00:07:22,866 --> 00:07:24,799
呃问题嗯

196
00:07:24,966 --> 00:07:28,366
我们看到这个CONS的方法在哪里有呢

197
00:07:28,366 --> 00:07:31,666
就是在这个double和这个这个

198
00:07:31,666 --> 00:07:34,899
Rio和image返回10步和虚步的这样子的

199
00:07:34,933 --> 00:07:36,199
一个呃

200
00:07:36,200 --> 00:07:38,266
方法上它会有呃

201
00:07:38,266 --> 00:07:40,866
这里需要注意的一个点就是说

202
00:07:41,600 --> 00:07:43,066
首先啊

203
00:07:43,100 --> 00:07:45,900
我们可以看到这两个CONS的关键字

204
00:07:45,966 --> 00:07:48,799
它是加在这个函数的这个是高

205
00:07:49,366 --> 00:07:52,266
就是函数实现定义的这个域的

206
00:07:52,266 --> 00:07:53,666
前面的说明呢

207
00:07:53,766 --> 00:07:55,333
这两个方法

208
00:07:55,866 --> 00:07:58,066
这两个方法或者说这两个成员函数

209
00:07:58,066 --> 00:08:00,933
他们是属于CONS的函数然后呢

210
00:08:01,133 --> 00:08:01,933
嗯

211
00:08:02,900 --> 00:08:05,600
虽然他们是这个啊抗死的函数

212
00:08:05,600 --> 00:08:06,600
但是我们

213
00:08:06,800 --> 00:08:08,166
假如说因为这个抗死

214
00:08:08,166 --> 00:08:10,899
他是考虑到针对这个对象本身

215
00:08:10,900 --> 00:08:13,966
假如我们现在初始了一个复述对象啊

216
00:08:13,966 --> 00:08:15,199
他是非抗死他的

217
00:08:15,200 --> 00:08:17,200
也就是说他是一个变量啊

218
00:08:17,333 --> 00:08:18,666
他并不是一个长量

219
00:08:18,666 --> 00:08:22,666
那么我们能不能去使用这个啊

220
00:08:22,666 --> 00:08:25,533
Const的这个呃

221
00:08:25,933 --> 00:08:26,999
这个函数呢

222
00:08:27,000 --> 00:08:30,000
嗯那么我们不如来试一试看一下

223
00:08:31,200 --> 00:08:34,500
嗯首先看到我这个测试的这个文件啊

224
00:08:34,666 --> 00:08:35,466
他已经

225
00:08:35,500 --> 00:08:38,100
引库着的这个complex的这个实现了

226
00:08:38,100 --> 00:08:40,166
实现的代码呢就在我刚刚这

227
00:08:40,366 --> 00:08:42,466
可以给大家看一下一样的

228
00:08:42,700 --> 00:08:42,966
然后

229
00:08:42,966 --> 00:08:45,899
除了后面我给了一些具体的实现之外

230
00:08:45,900 --> 00:08:47,700
其他内容都和我刚刚的

231
00:08:48,066 --> 00:08:49,966
文档里的这个定义是一致的

232
00:08:50,066 --> 00:08:52,166
那么我们这个首先啊

233
00:08:52,166 --> 00:08:57,366
我们来给出这个一个复述对象的一个

234
00:08:57,800 --> 00:08:58,700
呃con

235
00:08:58,700 --> 00:09:02,100
Const的一个相当于是创建一个Const的

236
00:09:02,333 --> 00:09:04,933
创建一个呃常数复数值

237
00:09:04,933 --> 00:09:07,399
然后我们来调用这个real方法

238
00:09:07,400 --> 00:09:11,000
这个real的话就是这个Const成员函数

239
00:09:11,100 --> 00:09:13,733
我们看一下这肯定是能够使用对不对

240
00:09:14,133 --> 00:09:17,599
啊正常来说他确实是肯定能够OK的

241
00:09:18,066 --> 00:09:19,466
好那我们继续啊

242
00:09:19,466 --> 00:09:22,899
我们把这个康斯特给他去除掉啊

243
00:09:22,933 --> 00:09:23,699
看看这个有

244
00:09:23,700 --> 00:09:24,500
没有问题

245
00:09:24,966 --> 00:09:28,899
就是能够看到的就是啊他也能够使用

246
00:09:28,933 --> 00:09:29,733
说明什么呢

247
00:09:29,733 --> 00:09:32,333
说明这个Const它的意义在于

248
00:09:32,333 --> 00:09:33,866
它就是Const

249
00:09:33,933 --> 00:09:36,699
注意Const成员函数的定义啊

250
00:09:36,700 --> 00:09:37,500
它是

251
00:09:38,300 --> 00:09:41,466
可以作用于Const对象

252
00:09:41,600 --> 00:09:44,300
以及非Const对象的啊

253
00:09:44,500 --> 00:09:47,966
那么Const这个成员函数它的意义啊

254
00:09:47,966 --> 00:09:48,999
我可以跟大家说

255
00:09:49,000 --> 00:09:51,166
这个Const的这个意义就

256
00:09:52,200 --> 00:09:53,566
或者说Const

257
00:09:53,900 --> 00:09:54,966
成员函数

258
00:09:55,166 --> 00:09:57,466
在这个Const在这里的意义就是

259
00:09:57,533 --> 00:09:59,533
对于这个呃

260
00:09:59,933 --> 00:10:02,366
呃成员的一种保护

261
00:10:03,366 --> 00:10:04,766
就是说首先这里

262
00:10:05,133 --> 00:10:06,399
实步和序步呢

263
00:10:06,400 --> 00:10:08,966
都是其实在这两个呃函数里面

264
00:10:08,966 --> 00:10:12,399
它其实是作为一个读的一个功能是吧

265
00:10:12,400 --> 00:10:15,933
那么我们就不应该去改变它的这个值

266
00:10:16,166 --> 00:10:17,766
所以说嗯

267
00:10:17,866 --> 00:10:20,799
在这个函数里面如果说我们去

268
00:10:21,366 --> 00:10:23,099
他是一个非抗死的的话

269
00:10:23,300 --> 00:10:25,800
他有可能我们就会因为一些操作

270
00:10:25,800 --> 00:10:27,866
导致我们去改变了他的这个

271
00:10:27,866 --> 00:10:29,399
成员的这个状态

272
00:10:29,400 --> 00:10:30,866
或者说改变了的值

273
00:10:31,200 --> 00:10:33,533
嗯那么我们家的抗死的话呢

274
00:10:33,533 --> 00:10:36,166
如果说我们在他的具体实现里面

275
00:10:36,200 --> 00:10:37,700
去做了这样的操作

276
00:10:37,700 --> 00:10:39,733
那么编译器是不能够

277
00:10:40,166 --> 00:10:42,366
呃会就是汇报错的

278
00:10:42,366 --> 00:10:44,199
因为我们这样子相当于是

279
00:10:44,300 --> 00:10:46,166
改变了他的状态啊

280
00:10:46,200 --> 00:10:47,300
所以说为什么

281
00:10:47,300 --> 00:10:49,300
这也是为什么这两个函数

282
00:10:50,300 --> 00:10:51,600
他不能加抗字的

283
00:10:51,600 --> 00:10:53,133
因为这两个函数是

284
00:10:53,300 --> 00:10:57,933
去切实的改变这个呃成员的这个值

285
00:10:58,100 --> 00:10:59,933
我们把实步和虚步的值

286
00:10:59,933 --> 00:11:01,999
变成了一个具体的值啊

287
00:11:02,100 --> 00:11:03,666
所以说这种时候呢

288
00:11:04,166 --> 00:11:06,299
他就是一个改变状态的一个功能

289
00:11:06,700 --> 00:11:08,600
这个时候他就肯定不是一个Const

290
00:11:08,600 --> 00:11:10,800
的一个方法OK

291
00:11:11,133 --> 00:11:12,466
所以我们能够看到啊

292
00:11:12,466 --> 00:11:14,466
现在我们把这个函数改成

293
00:11:14,566 --> 00:11:17,866
嗯只有点real two嗯

294
00:11:18,100 --> 00:11:20,533
然后呢我们再去

295
00:11:23,266 --> 00:11:25,166
打印它的这一个

296
00:11:28,333 --> 00:11:29,133
事故

297
00:11:33,966 --> 00:11:39,733
打呃我们再去这个打印他的这个实物

298
00:11:40,133 --> 00:11:41,766
啊这里打错了

299
00:11:43,533 --> 00:11:44,333
g t

300
00:11:44,700 --> 00:11:45,500
然后

301
00:11:49,400 --> 00:11:49,666
哎

302
00:11:49,666 --> 00:11:52,699
我们可以看到他的字被修改为2了啊

303
00:11:52,700 --> 00:11:53,733
这个时候他就

304
00:11:53,733 --> 00:11:55,699
他就是这样子的一个作用

305
00:11:55,700 --> 00:11:58,266
那么要注意的一点是什么呢

306
00:11:58,600 --> 00:11:59,933
其实这点还没有说完

307
00:11:59,933 --> 00:12:02,133
如果说我们把它改成了Const

308
00:12:02,733 --> 00:12:03,166
那

309
00:12:03,166 --> 00:12:03,999
就是不行的

310
00:12:04,000 --> 00:12:06,400
可以看到这个时候编译器或者说这个

311
00:12:06,533 --> 00:12:07,599
会提醒你啊

312
00:12:07,600 --> 00:12:08,800
因为你这个时候

313
00:12:08,966 --> 00:12:11,733
你在29行调用的这个real函数

314
00:12:11,866 --> 00:12:12,699
它是一个什么

315
00:12:12,700 --> 00:12:15,600
它是一个非Const的一个函数

316
00:12:15,600 --> 00:12:16,566
也就是说

317
00:12:16,700 --> 00:12:17,500
虽然

318
00:12:17,900 --> 00:12:21,000
啊这里要回到我们的这个文档这

319
00:12:21,500 --> 00:12:22,700
作用了这个问题

320
00:12:22,700 --> 00:12:24,500
作用了什么问题就是

321
00:12:24,600 --> 00:12:26,400
Const的函数

322
00:12:26,500 --> 00:12:30,000
能够作用于非Const和Const的对象

323
00:12:30,000 --> 00:12:36,200
但是Const对象只能够啊去调用这个

324
00:12:36,733 --> 00:12:40,266
Const的函数或者说Const的方法

325
00:12:40,466 --> 00:12:41,266
不应该说函数

326
00:12:41,266 --> 00:12:43,899
应该说只能调用Const的方法

327
00:12:43,900 --> 00:12:46,066
这个就是这里说的这个问题

328
00:12:46,066 --> 00:12:48,866
实际上这个东西你大家不用去应激

329
00:12:48,966 --> 00:12:51,199
因为只要理解了这个Const

330
00:12:51,200 --> 00:12:52,866
它的这个意义啊

331
00:12:53,000 --> 00:12:53,800
嗯

332
00:12:54,666 --> 00:12:56,966
其实这个东西

333
00:12:57,366 --> 00:13:01,099
你是能够去不需要记就可以理解的

334
00:13:01,200 --> 00:13:03,900
虽然说我认为在私家家里面

335
00:13:04,066 --> 00:13:07,333
CONS的语义有一些过于丰富了

336
00:13:07,666 --> 00:13:11,399
就是简单来说我觉得这个cost

337
00:13:11,900 --> 00:13:15,400
嗯对于初学者来说他不是这么友好

338
00:13:15,666 --> 00:13:18,599
因为他你想要真的了解他的话

339
00:13:18,933 --> 00:13:20,399
是需要付出一定的

340
00:13:20,400 --> 00:13:22,200
这个心智上的代价的

341
00:13:22,366 --> 00:13:23,699
我是这么认为的

342
00:13:23,966 --> 00:13:26,333
好我们把这个点说过了

343
00:13:26,333 --> 00:13:27,766
我们就来看下一个

344
00:13:28,533 --> 00:13:30,133
啊这里给的一个例子啊

345
00:13:30,133 --> 00:13:31,733
是书本上给的这个例子

346
00:13:31,733 --> 00:13:33,266
其实是跟我这里说

347
00:13:33,266 --> 00:13:34,266
的是一样的

348
00:13:34,333 --> 00:13:35,666
我们这里啊

349
00:13:35,666 --> 00:13:37,333
构造啊就是说去

350
00:13:37,500 --> 00:13:40,466
定义并初次化的一个CC这个复数啊

351
00:13:40,466 --> 00:13:42,266
他是一个抗死者的一个对象

352
00:13:42,333 --> 00:13:44,166
那么嗯我们

353
00:13:44,533 --> 00:13:45,966
在对这个

354
00:13:46,200 --> 00:13:46,933
把c c

355
00:13:46,933 --> 00:13:47,333
的值

356
00:13:47,333 --> 00:13:49,866
复制给一个非Const的一个变量的时候

357
00:13:49,866 --> 00:13:50,899
他是OK的

358
00:13:50,900 --> 00:13:52,533
但是呢啊他去

359
00:13:52,933 --> 00:13:56,266
给他复到z的值的时候他是不OK的

360
00:13:56,266 --> 00:13:58,599
因为这个会改变c c的一个状态

361
00:13:58,600 --> 00:14:01,300
所以说其实我们换一种角度来理解啊

362
00:14:01,533 --> 00:14:04,099
就能够明白啊这是不行的

363
00:14:04,100 --> 00:14:05,466
所以这个地方是一个l

364
00:14:05,466 --> 00:14:07,066
大家可以自己去试一下

365
00:14:08,900 --> 00:14:12,300
OK那么我们再看下一个问题

366
00:14:12,300 --> 00:14:15,900
就是a加等于b和a等于a加b的区别

367
00:14:15,900 --> 00:14:17,200
其实这个东西呢

368
00:14:17,733 --> 00:14:19,099
嗯看着很简单

369
00:14:19,100 --> 00:14:20,166
但这个东西

370
00:14:20,766 --> 00:14:25,299
就是涉及到这个家家里面的这个

371
00:14:25,566 --> 00:14:27,699
拷贝和移动的这个问题了

372
00:14:27,700 --> 00:14:31,700
这个的话我们在后面还会继续去深入

373
00:14:32,133 --> 00:14:34,466
去说这个东西我们这里只是

374
00:14:34,900 --> 00:14:37,466
简单的说一下啊其实这个问题

375
00:14:37,933 --> 00:14:39,333
他们这个区别

376
00:14:39,866 --> 00:14:41,333
嗯我相信很多

377
00:14:41,766 --> 00:14:43,933
西安家的课程里面都会提到

378
00:14:44,733 --> 00:14:46,066
这个我刚刚也说了

379
00:14:46,200 --> 00:14:48,133
在我这里实现的这个地方呢

380
00:14:48,133 --> 00:14:49,899
给到的是自增的实现

381
00:14:50,000 --> 00:14:52,933
我们实现的这个operator是一个加等于

382
00:14:52,933 --> 00:14:55,399
也就是说它其实对应的是第一个

383
00:14:55,600 --> 00:14:56,966
第一个表达式

384
00:14:57,200 --> 00:14:59,100
第一个expression啊

385
00:14:59,100 --> 00:15:03,100
这个a加a等于a加b呢实际上是呃

386
00:15:04,300 --> 00:15:07,533
对于复数的加法的一个函数的调用

387
00:15:07,533 --> 00:15:09,899
而这个对的调用的是这一个

388
00:15:09,900 --> 00:15:11,566
所以说他们其实是不一样的

389
00:15:11,566 --> 00:15:12,466
来看一下

390
00:15:13,966 --> 00:15:16,466
这里啊实际上调用的是

391
00:15:17,300 --> 00:15:18,600
嗯等于这个

392
00:15:19,500 --> 00:15:21,333
也就是我们上面定义的

393
00:15:21,400 --> 00:15:23,666
但是这个呢等于是

394
00:15:24,466 --> 00:15:26,666
等于其实做了两个步骤啊

395
00:15:26,766 --> 00:15:29,566
这里就是创建了一个临时对象

396
00:15:30,000 --> 00:15:32,566
然后呢啊再去

397
00:15:32,900 --> 00:15:34,733
做了一个直的

398
00:15:34,733 --> 00:15:36,466
一个覆盖的这样子一个操作

399
00:15:36,466 --> 00:15:37,866
也就说这一个过程

400
00:15:37,866 --> 00:15:40,333
其实比我们想象的要复杂一点啊

401
00:15:40,333 --> 00:15:42,966
这里做了一个操作然后

402
00:15:43,366 --> 00:15:44,766
这其实是个幼稚吧

403
00:15:44,766 --> 00:15:46,299
嗯如果说有同学知道的话

404
00:15:46,300 --> 00:15:48,200
大家这里这个幼稚

405
00:15:48,200 --> 00:15:50,300
这里做了一个呃

406
00:15:50,300 --> 00:15:55,066
从一个姜王子到呃纯幼稚的一个转变

407
00:15:55,066 --> 00:15:56,399
我这现在说的这个东西

408
00:15:56,400 --> 00:15:58,133
大家可能会有点懵啊

409
00:15:58,166 --> 00:16:00,266
但是可能有些人他知道我

410
00:16:00,566 --> 00:16:02,399
他们是有这个基础的

411
00:16:02,400 --> 00:16:03,866
就知道我的这个意思

412
00:16:04,100 --> 00:16:04,933
所以说

413
00:16:05,600 --> 00:16:08,733
嗯这一块他到底是有什么不一样

414
00:16:08,733 --> 00:16:10,466
我已经简单的跟大家说了

415
00:16:10,466 --> 00:16:14,199
我们一般使用嗯都会使建议使用这种

416
00:16:14,200 --> 00:16:15,733
因为这里其实是有两

417
00:16:17,900 --> 00:16:20,466
然后这里书上也提到了一下

418
00:16:20,466 --> 00:16:21,966
就是用户定义这个

419
00:16:21,966 --> 00:16:23,466
这里是运算符

420
00:16:28,900 --> 00:16:31,600
运算符啊应该就是去

421
00:16:31,866 --> 00:16:33,333
重载的这个运算符的

422
00:16:33,333 --> 00:16:35,966
就应该去谨慎的去使用啊

423
00:16:36,200 --> 00:16:39,000
OK这里我们就相当于给了这个

424
00:16:39,000 --> 00:16:40,366
复数的这个

425
00:16:41,466 --> 00:16:42,266
一个定义

426
00:16:42,266 --> 00:16:44,766
我们来简单总结一下这个复数的话呢

427
00:16:44,766 --> 00:16:46,099
它其实就跟

428
00:16:46,466 --> 00:16:47,933
啊我们的内置类型

429
00:16:47,933 --> 00:16:50,966
也就是我们内置的Inter啊

430
00:16:51,133 --> 00:16:53,466
double啊这些它特别的像啊

431
00:16:53,666 --> 00:16:56,099
它就是属于我们具体类型的一种

432
00:16:57,366 --> 00:16:59,499
接下来我们看这个容器类型

433
00:16:59,500 --> 00:17:00,300
我觉得

434
00:17:00,466 --> 00:17:03,133
具体类型呢是我们下家的一个重点

435
00:17:03,133 --> 00:17:03,933
因为

436
00:17:04,766 --> 00:17:05,733
很多时候

437
00:17:05,733 --> 00:17:08,699
你要做好定义好一个具体类型

438
00:17:08,800 --> 00:17:10,666
你需要嗯

439
00:17:10,666 --> 00:17:12,666
在内存的这个管理上面

440
00:17:12,666 --> 00:17:13,799
要有很多的考量

441
00:17:13,800 --> 00:17:17,000
特别是我接下来说的这个容器类型

442
00:17:17,100 --> 00:17:20,333
容器这个其实大家都呃

443
00:17:21,766 --> 00:17:24,466
知道了但是我这里要注意的一点

444
00:17:24,533 --> 00:17:27,166
我说的是具体的容器类型

445
00:17:27,166 --> 00:17:29,499
也就是我们下面给到的这个例子啊

446
00:17:29,600 --> 00:17:33,066
是首先容器是代表代表元素的集合

447
00:17:33,066 --> 00:17:34,533
然后我下面这个例子呢

448
00:17:34,533 --> 00:17:36,099
他定了一个vector对象

449
00:17:36,100 --> 00:17:37,733
简单的一个vector对象

450
00:17:38,000 --> 00:17:40,400
嗯就是一个项链对象那么这个

451
00:17:42,133 --> 00:17:42,599
嗯

452
00:17:42,600 --> 00:17:45,366
容器类型的构造函数和西构函数啊

453
00:17:45,366 --> 00:17:46,499
分别就承担了

454
00:17:46,500 --> 00:17:47,766
在我们这个定义里面

455
00:17:47,766 --> 00:17:49,566
就承担了分配内存啊

456
00:17:49,566 --> 00:17:53,166
注意要仔细的琢磨这几句话就是

457
00:17:53,666 --> 00:17:55,899
构册函数承担了什么分配内存

458
00:17:55,933 --> 00:17:58,999
给定初始值这其实是两个操作啊

459
00:17:59,333 --> 00:18:02,066
然后同时我们要养成一个好习惯

460
00:18:02,066 --> 00:18:04,733
就是说我们去做一个构册函数的时候

461
00:18:04,733 --> 00:18:06,699
我们不仅要给他分配内存

462
00:18:06,700 --> 00:18:09,066
我们还要给定对应的初始值

463
00:18:10,466 --> 00:18:13,366
像我们这个定义里面他就有道嗯

464
00:18:13,733 --> 00:18:16,866
这里就有一个这个构造方法

465
00:18:16,866 --> 00:18:17,699
然后呢

466
00:18:17,733 --> 00:18:21,533
他给到的这个值是单个这个数值

467
00:18:21,966 --> 00:18:22,966
相当于我

468
00:18:23,000 --> 00:18:25,500
这个对应的就是我们这个Wifi的size了

469
00:18:25,500 --> 00:18:28,100
我们就会分配一段内存啊然后呢

470
00:18:28,166 --> 00:18:31,066
啊给到就因为我们的这个纸啊

471
00:18:31,133 --> 00:18:34,333
两个他的两个成员呢是有成员一个是

472
00:18:34,700 --> 00:18:37,400
他具体的这个纸一个是他的size嘛

473
00:18:37,533 --> 00:18:39,199
然后都给他分配好了

474
00:18:39,200 --> 00:18:41,800
接着我们第二步啊

475
00:18:42,266 --> 00:18:43,733
就是初始化这些

476
00:18:43,866 --> 00:18:46,466
与它里面这个内置列表

477
00:18:46,500 --> 00:18:49,166
呃或者说内置RE的这个具体的值

478
00:18:49,166 --> 00:18:50,866
把它们全部赋予了0

479
00:18:51,466 --> 00:18:53,166
所以说这里承担了两步

480
00:18:53,333 --> 00:18:54,166
然后呢

481
00:18:54,300 --> 00:18:56,866
这个c个函数呢就是我们去做了

482
00:18:56,866 --> 00:18:57,966
其实就是去

483
00:18:58,400 --> 00:19:00,733
调用这个销毁

484
00:19:01,366 --> 00:19:02,566
销毁运算符啊

485
00:19:02,566 --> 00:19:03,766
把我们的这个

486
00:19:03,766 --> 00:19:05,666
内部这个东西给他销毁掉了

487
00:19:05,666 --> 00:19:06,933
就这么一个作用

488
00:19:08,133 --> 00:19:14,199
OK然后分配动态空间的方法是6运算符

489
00:19:14,966 --> 00:19:17,899
与日对应呢释放内存的运算符是delete

490
00:19:18,866 --> 00:19:19,699
还有delete

491
00:19:19,700 --> 00:19:23,566
然后加上这个SS这个operator代表

492
00:19:23,766 --> 00:19:26,399
这个前面的delete代表是删除普通对象

493
00:19:26,400 --> 00:19:27,966
后面是销毁的是LV

494
00:19:27,966 --> 00:19:29,133
注意这两个

495
00:19:29,166 --> 00:19:29,899
还有这一个

496
00:19:29,900 --> 00:19:33,100
他们都会涉及到具体内存上的变动啊

497
00:19:33,933 --> 00:19:37,166
所以说跟拍审什么的这类的语言

498
00:19:37,166 --> 00:19:38,166
很大的一个区别

499
00:19:38,166 --> 00:19:38,966
就是说

500
00:19:39,400 --> 00:19:43,866
他们会确切切实实实的去动到那个

501
00:19:44,600 --> 00:19:45,733
内存的值

502
00:19:45,933 --> 00:19:47,666
我们一定要注意这一点

503
00:19:48,133 --> 00:19:49,733
同时我们要注意

504
00:19:49,866 --> 00:19:52,266
尽量不要在代码中直接使用

505
00:19:52,266 --> 00:19:54,066
6和DELE的运算符

506
00:19:54,066 --> 00:19:56,866
为啥嗯因为

507
00:19:57,533 --> 00:20:00,533
这个东西就是C++的一个原则

508
00:20:00,533 --> 00:20:01,333
就是

509
00:20:02,133 --> 00:20:05,799
我们通过嗯这个符号啊

510
00:20:06,300 --> 00:20:08,800
每次这个寓意结束的时候

511
00:20:08,933 --> 00:20:10,999
他的这个嗯

512
00:20:11,366 --> 00:20:14,766
域里面的这些成员的这个呃

513
00:20:15,400 --> 00:20:16,733
值都会

514
00:20:17,466 --> 00:20:19,799
达到做一个销毁的一个动作

515
00:20:19,800 --> 00:20:21,966
也就是会去调用西瓜函数啊

516
00:20:22,100 --> 00:20:22,900
然后呢

517
00:20:22,900 --> 00:20:25,900
通过这一个以及我们给他给对象

518
00:20:26,366 --> 00:20:28,899
实现的这个构造函数和西瓜函数

519
00:20:28,900 --> 00:20:32,266
我们能够很好的去控制我们的这个

520
00:20:32,333 --> 00:20:34,099
呃运行时

521
00:20:34,600 --> 00:20:37,400
的整个内存状态啊

522
00:20:37,500 --> 00:20:38,700
这个是我们

523
00:20:39,300 --> 00:20:40,300
需要了解的

524
00:20:40,300 --> 00:20:42,100
下载内存管理的第一课

525
00:20:42,100 --> 00:20:44,500
就是我们要通过这个符号啊

526
00:20:44,500 --> 00:20:45,300
以及

527
00:20:46,200 --> 00:20:47,666
以及动态呃

528
00:20:47,666 --> 00:20:50,333
以及这个构造函数和西瓜函数来实现

529
00:20:51,000 --> 00:20:52,533
这个其实是比较重要的

530
00:20:52,533 --> 00:20:55,599
后面的话我们会继续去深入这个课题

531
00:20:55,800 --> 00:20:56,766
那我们再看啊

532
00:20:56,766 --> 00:20:59,499
就是首先我们看一下这个vector

533
00:21:00,066 --> 00:21:01,499
按照我们这样的定义

534
00:21:01,700 --> 00:21:03,666
他的这个内存视图是怎么样的

535
00:21:03,666 --> 00:21:04,466
他其实对应的

536
00:21:04,466 --> 00:21:06,099
就是因为他有两个成员吗

537
00:21:06,166 --> 00:21:08,899
一个就是对应他的SIS

538
00:21:09,066 --> 00:21:10,166
这个就不用多说了

539
00:21:10,166 --> 00:21:12,099
一个对应的其实是一个指针

540
00:21:12,133 --> 00:21:13,199
这个指针呢

541
00:21:13,200 --> 00:21:17,166
指向的就是前面我们摘药那里说到的

542
00:21:17,400 --> 00:21:20,900
具体的一个vector里面的

543
00:21:22,266 --> 00:21:24,333
呃这个

544
00:21:25,666 --> 00:21:28,499
这个具体的这个vector它的一个头部啊

545
00:21:28,500 --> 00:21:29,866
也就是说其实这个

546
00:21:30,100 --> 00:21:32,133
指针指向的就是这样子一个vector

547
00:21:32,133 --> 00:21:34,399
而且它是一个呃顺序表

548
00:21:34,400 --> 00:21:36,300
它的内存上面它是连续的

549
00:21:36,333 --> 00:21:39,799
然后啊他们就对应的就是关系

550
00:21:39,800 --> 00:21:42,366
就是如图所示啊

551
00:21:43,100 --> 00:21:44,700
这个也不用多说了

552
00:21:44,866 --> 00:21:47,099
然后其实到这一块呢

553
00:21:47,100 --> 00:21:49,000
我们就讲的差不多了

554
00:21:49,000 --> 00:21:51,933
然后我们会留下一些问题啊

555
00:21:52,166 --> 00:21:53,133
这个问题的话

556
00:21:53,133 --> 00:21:54,933
我可以简单给大家看一下啊

557
00:21:55,333 --> 00:21:57,399
就是说我们想要深入刚刚的课题

558
00:21:57,400 --> 00:21:58,166
因为我们刚刚

559
00:21:58,166 --> 00:21:59,733
简单定义了一个复数类型

560
00:21:59,733 --> 00:22:01,766
那么我们可能还会去考虑啊

561
00:22:01,766 --> 00:22:04,499
如果说我们要定义工业级强度的一些

562
00:22:04,500 --> 00:22:08,300
比如说呃无上限的这个超大型整数

563
00:22:08,400 --> 00:22:10,166
或者说是呢啊

564
00:22:10,366 --> 00:22:12,533
更好的去学习这个vector

565
00:22:12,600 --> 00:22:15,266
这个定义我们应该怎么做啊

566
00:22:15,266 --> 00:22:16,199
因为我们刚刚说的

567
00:22:16,200 --> 00:22:18,200
其实是一些很基本的东西

568
00:22:18,200 --> 00:22:19,533
他们是一些皮毛

569
00:22:19,566 --> 00:22:22,399
虽然是皮毛但是他们也很重要啊

570
00:22:22,733 --> 00:22:23,666
具体这一些

571
00:22:23,666 --> 00:22:26,333
我会在下一个讲完抽象类型之后

572
00:22:26,333 --> 00:22:28,533
我们去把这些问题做一个回顾

573
00:22:28,600 --> 00:22:29,466
这些问题呢

574
00:22:29,466 --> 00:22:32,099
是我在实际学习当中遇到的一些

575
00:22:32,166 --> 00:22:33,299
啊这个问题

576
00:22:33,300 --> 00:22:34,733
然后嗯

577
00:22:34,733 --> 00:22:38,266
大家也可以去先去把这些问题看一看

578
00:22:38,266 --> 00:22:39,799
然后自己去思考

579
00:22:39,900 --> 00:22:41,266
所以说嗯

580
00:22:41,566 --> 00:22:43,566
我们具体类型就已经讲了

581
00:22:43,566 --> 00:22:46,299
最典型的两种场景算数类型啊

582
00:22:46,300 --> 00:22:47,600
还有这个容器类型

583
00:22:47,766 --> 00:22:50,333
那么这是相当于是两个例子吗

584
00:22:50,333 --> 00:22:52,399
其实具体类型嗯

585
00:22:52,766 --> 00:22:54,999
他的一定义是具体是什么

586
00:22:55,000 --> 00:22:56,366
一开始已经说了

587
00:22:56,400 --> 00:22:59,000
然后我们下一讲会讲一讲抽象类型

588
00:22:59,000 --> 00:23:01,866
并去解决刚刚我给大家展示的这个

589
00:23:01,866 --> 00:23:04,666
问题好我们这一期的内容就到这

