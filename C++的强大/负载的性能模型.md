# 负载性能模型

* 软件世界中有很多benchmark（基准），如我们测试个人PC性能常用的软件，比如鲁大师
* 如何设计一个好的benchmark？
* 由于软件的运行特征本身太过于宽泛。想要了解一个负载的性能，我们需要先对软件性能本身进行建模





## 负载的特征
负载本身应该满足的基本条件：
* 具有通用的性能分评价指标
* 包含一个全量测试，能在任意系统上执行并给出性能指标

### 通用评价指标
* 性能分
* 能效分

### 通用特征
* CPU利用率
* 内存

### 其他特征
* OPS(OP是CPU指令)


### 体系结构和微体系结构

* 体系结构是处理器处理器软件和硬件之间的接口，通过指令集来规定。简单概括：汇编程序员能够直接使用的功能。一般称为instruction set architecture，其典例有X86-32，X86-64，ARMv8，ARMv9
* 微体系结构是为提高处理性能而专门设计的结构，如cache, branch predictor, ROB。可以看出不是必需的。



### 静态微架构无关特征



任何程序都能被表征为一个汇编指令文件，换句话说，任何程序都能被表示为指令序列集合。统计指令序列的一些重要的值形成了重要的特征，其中：

* 不包含处理器微体系结构的信息
* 也不包含程序运行的动态信息

的特征被称为静态微架构无关特征：

* 汇编码的基本块数量

#### 基本块的含义

```c++
int foo(int x) {
    int y = x + 1;
    int z = y * 2;
    return z;
}
```

上面的代码经过编译后，生成的汇编码如下：

```assembly
foo:
    movl %edi, %eax
    addl $1, %eax
    leal (%rax,%rax), %eax
    retq
```

## 基本分类方法
首先需要明确的是，以衡量性能/能效作为前提，则测试对象是SUT（system under test），是运行负载的整套计算机系统。

给不同的任务进行分类实际上是一个困难的过程，因为计算任务的特征可以在硬件，业务目的等不同维度体现，但这些维度本身不好归结为一套评价体系，另一方面，在单一维度中，一个任务的分类方法也无法直接量化（举个例子，一个任务完全可以即是任务密集型又是内存密集型，任务在这两者上的压力都足够大，但由于CPU和RAM完全是不同的部件，不存在直接量化的边界），从这个角度看，使用聚类的思路来对任务重新分类是一个更好的思路(但是注意，这必须以通用的性能指标作为前提)。因此下面的分类更多是从基准设计的角度出发，以人的经验构成的分类标准。

### 按照计算机组成部件
* CPU密集型
* 内存访问密集型
* 磁盘访问密集型
* 网络密集型
* 加速器设备

### 按照业务分类
这一项也可以参照openbenchmarking.org提供的"suites"来分类。
* 操作系统类测试
* 数值计算/HPC
* 语音/视频处理
* 编译器
* 数据库操作
* web test
* 文件压缩
* 加密
* 图形化

### 按照计算业务进行分类
* CPU负载
  * 单线程负载
  * 多线程负载
  * 集群负载
  * 延迟敏感
  * 批处理
  * 微服务
  * 流式处理
  * 批流融合
  * WASM
* GPU负载
  * CUDA流式负载
  * CUDA非流式负载

## 实际案例

### 吞吐量瓶颈
一台全闪存服务器上做大量的文件IO,性能瓶颈在哪，可能的点：
* SSD本身的承载能力
* 做IO的逻辑核数
