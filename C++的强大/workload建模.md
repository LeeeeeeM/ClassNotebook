# workload建模
软件侧自顶向下收敛于任务（OS）和指令（ISA），硬件侧自底向上收敛于架构（Arch）。所以负载的建模需要在这三层进行。

做workload建模，主要是两个方向上的事：
* 白盒：描述场景在上述层级上的特征；(workload画像)
* 黑盒：给出最典型的测试用例

## 黑盒削减
* 基于指令流片段截取
* 基于参数模型实体化

### 指令流片段截取
该方法具有可行性，是基于以下两个前提
* 程序的行为具有周期性
* 用一个周期的指令流作为实体模型

问题：
* 如何高效抓取指令流
* 复杂软件栈（CUDA）如何处理
* 如何选取代表性周期
* 多核情况如何处理

具体需求：
目标为具体应用，从任意位置开始，存储任意长度的执行信息（指令，访存，系统调用）。通过工具将信息还原为可执行workload（ELF文件）。AArch64是Load/Store架构，寄存器和内存是所有的执行上下文，切片能够保证复现原始执行逻辑和访存行为

实现思路：
* 基于DBI工具（比如Dynamorio）执行信息抓取：
    * 基于动态二进制注入，注入序列全汇编极速优化
    * 抓取模式（跳过指定动态指令数，特殊指令触发）
* ELF还原（基于objdump二次开发）


### 参数模型实体化
抓取运行时特征，通过算法生成分布和原来相似的程序：
* 指令分布
* 指令级并行
* 指令局部性
* 数据局部性
* 控制流转移

问题：
生成性能指标类似的程序几乎不可能
