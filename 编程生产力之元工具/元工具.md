# 编程中的元工具

* 调试器（debugger）
* 包管理器（package manager）
* 构建系统（build system）
* 链路跟踪，性能分析等（tracer, profiling tools）
* 张量-编译器(tensor compiler)



## 内容讲解

如何创建一个便利，强大，高效C++,Python编程的学习，开发环境



工具包括：

* Docker(较新版本)+wsl2
  * docker ce
  * 有一个对应的docker镜像
* conda
* vscode
* jupyter notebook(cling+clang)
* gdb
* cython
* chatgpt





* Docker创建开发容器
  * ~~基于wsl2的docker容器（可以使用GPU）~~
  * ~~vscode + docker container~~
* 使用Cling学习C++
  * Cling+MS，Learncpp教程的组合（语法+词法学习）
  * 讲解Cling如何导入库
  * 使用Cling探索bigInt
  * Cling结合探索CUDA
* Cling背后的原理
  * 讲解LLVM，Clang的背景和工具意义
  * Cling软件架构，运行视图
* 超强内存分析工具Memray
  * Memray基本使用（参考文档）
  * Memray分析推理框架工作时的堆内存
  * Memray工作原理
* 用GDB调试Memray和其他Cython开发的软件
  * 确保编译的动态库带有调试符号
  * rbreak来打断点
  * 结合Python脚本来更好地分析Tracker中的代码
* GDB从入门到精进
  * GDB基本用法
  * GDB结合Python，更强的调试工具
  * GDB多线程案例
  * PDB工具
* TVM编译算子库
  * 

## termux
作为提供tab生产力，我们需要好好研究下这个工具

### 机理
termux属于终端模拟器，使用"execve"系统调用并重定向标准输出的方法来工作。多数的安卓终端模拟器只具备非常少的权限，但在termux上，你能运行绝大多数的GNU软件。
首先，**termux并不是虚拟机**。所有提供的软件包都通过安卓NDK交叉编译，由于缺少完整的文件访问权限，termux并不能将文件放置在诸如/bin,/usr这样的路径，而是统一放在了`/data/data/com.termux/files/usr`,这个路径被称为"prefix"，环境变量里的"$PREFIX"也是这个路径。注意这个路径不能被更改，因为：
* 文件系统必须支持unix权限和特殊文件，如符号链接
* 该前缀路径在termux项目中被硬编码了（没错，termux是开源的）

### termux不符合FHS标准
这就是termux不使用Debian或者Ubuntu作为标准环境的原因了。Filesystem Hierarchy Standard是LINUX基金会制定的标准unix系统所需要满足的约定。因此termux上的应用都需要在特定环境重新编译一次。不过这个问题还是比较好解决的

### 是否需要root
如果你想做下面这些事，那你需要root：
* 修改设备固件
* 修改内核参数
* 全部文件的读写权
* 对硬件设备模块有直接访问权限
* 


## 开发容器管理
一个可随时**迁移，并同步的开发环境**是非常重要的。

### 相关工具集
* chroot
* vagrant
* docker
* lxc rootfs
* Nix

### 理念
可以看看vagrant作者对于隔离环境的看法：[看法](stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment)
实际上vagrant不应该和docker本身比较，而是和Boot2Docker（一个可以运行Docker的最小操作系统）

### Portable Development-environment
![容器VS虚机](/storage/dcim/Screenshots/Screenshot_20230728_195323_WPS%20Office.jpg)

工具应该具备的特性：
* flexibility
* reproducible results
* 能够支持多种镜像格式：
  * Docker Images
  * CHOS Images
  * vmware Images



### 容器软件

#### Shifter containers for HPC


[项目](github.com/NERSC/shifter)
![软件架构](/storage/dcim/Screenshots/Screenshot_20230728_195424_WPS%20Office.jpg)
![性能损失](/storage/dcim/Screenshots/Screenshot_20230728_195348_WPS%20Office.jpg)

shifter是专为HPC应用设计的镜像引擎，它由几部分组成：
* 为应用创建执行环境的工具集
* 镜像网管系统，将镜像重新打包以适应squashfs



#### Docker4c
一个专门为C／C++开发设计的容器环境:
[blog](arne-mertz.de/2021/07/docker4c-portable-c-development-environment/)
里面包含的内容包括：
* compiler
* cmake
* Conan



### 了解runc

### 使用lxc容器
使用docker容器存在一些问题：
* 容器的根文件系统使用overlayfs，添加文件或者是删除文件，文件系统占用空间都不会减少
* 容器删除后，未提交的修改都会被丢弃，但不断提交会使得镜像体积膨胀

可以从Linux Container社区下载根文件系统tar包，解压系统到宿主机，使用hello world镜像创建容器，将该文件系统挂载到容器


## 调试器

### 自己开发ptrace based debugger

## shell
下面介绍一些对于我工作，生活特别有意义的一些命令行工具（主要是unix类的）
首先会介绍一些存储，网络相关的通用命令，解决磁盘以及网络管理的硬需求

### devbox(Nix)
官方说法“Reproducible development environments wherever you go“，这个概念接近于我前面提到的Portable dev env


### 存储相关的工具

#### lsblk
以树形结构列出所有块设备，输出信息中各列的意义介绍：
* NAME:设备名称，包括磁盘，分区，RAID，LVM
* MAJ:MIN:设备的主次设备号，用于唯一标识设备
* RM：是否为可移动设备，0表示不可移动，1表示可移动
* SIZE：设备大小，以字节为单位
* RO:是否为只读设备，0表示可读写，1表示只读
* TYPE:类型。
  * disk 磁盘
  * part 分区
  * raid RAID
  * lvm LVM(逻辑卷管理器)
* MOUNTPOINT:设备的挂载点，如果未挂载则为空

#### mount
#### e2fsck
用于检查和修复ext4文件系统的命令。


#### fdisk/parted
fdisk是Linux下的磁盘分区工具，可以用来创建，删除，调整MBR分区，下面列出常用方法：
* 

#### hwinfo

### GDB介绍

GDB是GNU组织发布的UNIX平台下的程序调试工具，同样基于ptrace系统调用，使用监控程序检查和改变被追踪者的内存及寄存器。

gdb最重要的几个用途：

* 入侵程序runtime，读写数据
* 主要支持大多数编译型的语言



几个问题：

* 我的GDB workflow

* GDB和Python到底什么关系？
* GDB可以调试Python程序吗？咋做？
* GDB对于Python开发者以及混编开发者最大的作用



#### gdbinit

* gdbinit是什么
* 使用gdbinit可以做到什么



#### GDB调试方法

* 直接启动进程调试 -> gdb [program]
* 调试core文件 -> gdb [program] [core] ： 拿到core查看出问题的调用栈，寄存器信息
* gdb -p pid



#### 常用命令

最好用命令：gdb -tui或**依赖vscode以及gdb-gui等工具**



* 设置断点
  * b <src:line>
  * b func_name

  * 删除断点：delete n（n代表第n个断点）

* 查看堆栈信息

  * 打印最内层：bt n
  * 查看所有线程：thread apply all bt

* 线程

  * 转到某线程： thread thread_number

* 栈帧

  * frame n

* 执行下一步命令（单步）

  * next




#### gdb奇巧

* gdb --args



#### 使用Python扩展gdb

##### case1：深入Python进程，做些恶作剧

```shell
./configure --with-python
# 在gdb进程中嵌入Cpython解释器
# 这个命令+python debug symbols
```

GDB的Python扩展能够给到我们什么：

* 在GDB中访问高层级的CPython解释器信息
* 在Python代码中访问GDB命令
* 定制化GDB commands



常用的访问Python信息的GDB命令：

* python [command]
* py-list
* py-bt
* py-up/py-down
* pylocals
* py-print



```shell
gdb -p <pid> -x gdb_commands.py
# 让gdb内的Cpython读取py_ext，获取新命令
```



```python
import gdb
# gdb.execute()是王道API，可以直接指定gdb去做任何事，有点像subprocess.Popen
gdb.execute()
# 那么,gdb里的 `call <expr>`又有什么讲究呢？
# 1.首先gdb会去查表，查符号表，找到所有函数的符号
# 2.查表会找到函数的对应地址，然后强制进程跳转到对应内存地址执行相应指令
# 3.configure with Cpython允许你call <C API>
```



一些重要的C API

* PyRun_SimpleString("<any python string>")
* PyGILState_Ensure()
* PyGILState_Release()



##### case2：进一步封装C++对象，inspect them





## REPL

### 主题：C++的REPL实现

#### C++语言解释层

详情请关注：https://compiler-research.org/libinterop/

这里将一些个人认为重要的观点谈一下。

Python在科学计算以及范·机器学习领域内有很强大的生态，一个非常关键的因素就是其可交互性，结合其本身的胶水特性，Python在进行各种research的工作中可谓是神器。

依赖Pybind11这样的构筑在Python C-API上的C++ API，Python得以将native语言的高性能优势发挥出来。然而，这样的做法存在局限性，首先是这种binding方法属于静态的binding，效率上存在缺陷，另一方面是“trampoline functions”的问题：

```
在 Pybind11 和其他类似工具中，要在 C++ 类型和 Python 类型之间建立映射关系，通常需要使用类似于 trampoline 的方法。简单来说，trampoline 函数是一个中间层，负责将 Python 对象的调用转发到底层的 C++ 对象上。在 Python 中，当子类继承自父类时，通常需要将子类的对象向上转换为父类的对象，因此需要在 C++ 和 Python 中使用不同的 trampoline 函数来处理继承关系。这些 trampoline 函数通常会在绑定代码中生成，以确保 C++ 对象的函数在 Python 中的调用能够正确地处理继承语义。

然而，在某些情况下，这些 trampoline 函数可能需要重复定义和生成，以满足不同的继承关系。这些被称为 "redundant trampoline functions"（冗余的 trampoline 函数），因为它们可能会在代码中重复出现，导致代码变得冗长和难以维护。举个例子，如果一个 C++ 类型被多个 Python 类型继承，那么需要为每个 Python 类型都定义一个 trampoline 函数，这可能导致许多相似的函数定义。这是一种常见的问题，可能会导致代码的不必要的膨胀和维护成本的增加。
```

另一方面，很多人认为动态绑定的效率一定比静态绑定要低，这实际上是个误区。



### cling介绍

C++是难以学习的一门语言，为了更好的掌握它，一些工具可能会帮到你很多。比如C++ REPL cling

相比于C++，Python会更容易学习，实际上这不单是语言复杂度的问题，我认为还有一个很原因是Python对于新人来说，**可交互性会更好**，自带REPL运行模式的解释器，而且这是一种常用模式，比如我们所熟知的Jupyter也是基于这种使用习惯所诞生的产品。REPL使我们可以更频繁地与Python语言本身交互，进行数据的探索，对于科学计算，数据分析类的应用而言，这至关重要，另一方面，这种探索也能快速提高一个人对于语法以及词法的熟练程度。



#### 原理介绍

参考文章https://blog.llvm.org/posts/2020-11-30-interactive-cpp-with-cling/

**Cling支持完整的C++特性**。包括模板，lambdas，虚拟继承。而Cling是在Clang和LLVM编译器架构上开发的一款应用。



![image-20230330004813608](statics\image-20230330004813608.png)

* 该工具通过交互式提示符或者一些REPL接口处理增量输入
* 将clang发送给其依赖的clang库进行编译，clang编译输入内容，将其转化为AST（②，③）
* 特殊情况下，AST要做进一步的转换（④）
* 将AST转化为LLVM-IR（⑤），LLVM-IR再次提交给JIT编译架构，去运行特定函数（⑥）
* 最终，生成的机器码（⑦）被提交给对应的处理硬件



C++本身的设计并没有考虑交互性，全局scope的声明执行，报告执行结果，实体的重定义是体现REPL用户友好性的最重要的三个特性。



#### 常用操作

##### 学习C++语法知识



##### jupyter notebook打开

启动对应的容器命令

```shell
docker run -it --network host --gpus all /bin/bash
```



启动jupyter notebook

```shell
setsid jupyter notebook --port=8888 --no-browser --ip=0.0.0.0 --allow-root
```



##### 写CUDA



##### 调试动态库文件

以dlib的matrix对象为例，演示如何调试库中的对象

* 以debug模式编译dlib，并且生成动态库二进制文件
* 



##### 像Python一样写use case



##### 查看数据结构，数据类型



## Profiling tools

### libunwind

libunwind是内存分析工具memray所依赖的核心组件之一，



## compiler

### loopy介绍



## AI assistance

### chat-gpt

下面给出一些图例来说明chat-gpt在不同场景下对于开发的帮助（基于gpt-3.5）。

#### 学习编程语言的特性

