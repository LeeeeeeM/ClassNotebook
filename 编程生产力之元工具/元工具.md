# 编程中的元工具

* 调试器（debugger）
* 包管理器（package manager）
* 构建系统（build system）
* 链路跟踪，性能分析等（tracer, profiling tools）
* 张量-编译器(tensor compiler)



## 内容讲解

如何创建一个便利，强大，高效C++,Python编程的学习，开发环境



工具包括：

* Docker(较新版本)+wsl2
  * docker ce
  * 有一个对应的docker镜像
* conda
* vscode
* jupyter notebook(cling+clang)
* gdb
* cython
* chatgpt





* Docker创建开发容器
  * ~~基于wsl2的docker容器（可以使用GPU）~~
  * ~~vscode + docker container~~
* 使用Cling学习C++
  * Cling+MS，Learncpp教程的组合（语法+词法学习）
  * 讲解Cling如何导入库
  * 使用Cling探索bigInt
  * Cling结合探索CUDA
* Cling背后的原理
  * 讲解LLVM，Clang的背景和工具意义
  * Cling软件架构，运行视图
* 超强内存分析工具Memray
  * Memray基本使用（参考文档）
  * Memray分析推理框架工作时的堆内存
  * Memray工作原理
* 用GDB调试Memray和其他Cython开发的软件
  * 确保编译的动态库带有调试符号
  * rbreak来打断点
  * 结合Python脚本来更好地分析Tracker中的代码
* GDB从入门到精进
  * GDB基本用法
  * GDB结合Python，更强的调试工具
  * GDB多线程案例
  * PDB工具
* TVM编译算子库
  * 

## termux
作为提供tab生产力，我们需要好好研究下这个工具

### 机理
termux属于终端模拟器，使用"execve"系统调用并重定向标准输出的方法来工作。多数的安卓终端模拟器只具备非常少的权限，但在termux上，你能运行绝大多数的GNU软件。
首先，**termux并不是虚拟机**。所有提供的软件包都通过安卓NDK交叉编译，由于缺少完整的文件访问权限，termux并不能将文件放置在诸如/bin,/usr这样的路径，而是统一放在了`/data/data/com.termux/files/usr`,这个路径被称为"prefix"，环境变量里的"$PREFIX"也是这个路径。注意这个路径不能被更改，因为：
* 文件系统必须支持unix权限和特殊文件，如符号链接
* 该前缀路径在termux项目中被硬编码了（没错，termux是开源的）

### termux不符合FHS标准
这就是termux不使用Debian或者Ubuntu作为标准环境的原因了。Filesystem Hierarchy Standard是LINUX基金会制定的标准unix系统所需要满足的约定。因此termux上的应用都需要在特定环境重新编译一次。不过这个问题还是比较好解决的

### 是否需要root
如果你想做下面这些事，那你需要root：
* 修改设备固件
* 修改内核参数
* 全部文件的读写权
* 对硬件设备模块有直接访问权限
* 

## 包管理器/构建系统

### 依赖管理

#### 编程语言的module system
考虑自己去设计一个模块系统，会发现设计空间是很大的。模块可能是由文本组成的（C），也可能是运行时的代码（Python），不妨想象一个简化版本的模块系统，很多问题会变得简单：
* 一个文件 = 一个模块
* 文件的名字 = 模块的名字
* 目录 = 项目
* 

##### python的module系统
一些要点：
* Python的import机制是一种延迟加载机制，只有在需要访问模块中对象的时，才会进行加载和执行
* Python支持动态导入模块，使用importlib来动态加载模块
* 搜索模块：Python会在当前目录，Python标准库目录，环境变量中PYTHONPATH指定的目录，第三方库目录，但是只要记住统合起来都会在"sys.path"中进行搜索
* 编译模块：当搜索到了要导入的模块，Python解释器会将其编译为字节码文件（pyc或pyo文件），保存在__pycache__目录中

Python当中的模块对应到的是一个以py为后缀名的源码文件，Python还有一个语言特定的概念，包（Package），首先：**包也是一个模块，包可以包含子模块或者是子包，包也是一个有__path__属性的模块**，创建一个包的方式是，新建一个目录，然后在目录中创建__init__.py，当这个包被当做模块导入时，`__init__.py`中的内容便是会被导入的内容。

需要注意的是，当你import一个包的时候，包的子模块和子包并不会被导入，你需要在__init__.py中将这些模块导入进来（直接通过`import xxx`的方式无法导入）。

但是你可以通过"from package import submodule"（subpackage）的方式去显式地导入子模块

**需要记住的事：当你导入一个模块，你会创建一个新的命名空间并把模块中的内容load进这个命名空间中**，命名空间是基于Python的字典数据结构实现的，可以通过`module.__dict__`的方式来访问具体的对象

##### c/c++的include系统



#### distributing/setup

##### 安装Python软件包
我们大多使用pip来安装pypi上的软件包，软件包以两种形式存在：
* source distributions
* wheels
如果pypi上两种资源都存在，pip会优先选择wheel，wheel是一种预编译的发行包，它会包含编译好的二进制扩展。

##### setup.py的背后
首先我们要了解


#### CMake/make系统
之前已经简要介绍过了CMake的作用。我们以unix下的安装过程举例，一般安转一个软件包，安装的内容包括：
* 可执行文件(bin)
* 头文件(相当于对外暴露的接口，include)
* 库文件(lib)
* cmake文件(share/package)
安装的内容普遍是安装到"prefix"下（通常是/usr/local）

### 构建系统
构建系统是和语言强绑定，我们主要看C++，python这两个语言的一些项目和常规方法


## 开发容器管理
一个可随时**迁移，并同步的开发环境**是非常重要的。

### 相关工具集
* chroot
* vagrant
* docker
* lxc rootfs
* Nix

### 理念
可以看看vagrant作者对于隔离环境的看法：[看法](stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment)
实际上vagrant不应该和docker本身比较，而是和Boot2Docker（一个可以运行Docker的最小操作系统）

### Portable Development-environment
![容器VS虚机](/screen_shot/Screenshot_20230728_195323_WPS%20Office.jpg)

工具应该具备的特性：
* flexibility
* reproducible results
* 能够支持多种镜像格式：
  * Docker Images
  * CHOS Images
  * vmware Images


### 前菜：通过bocker了解docker

#### 了解btrfs
简言之是"Better FS",suse和fedora的默认文件系统,具备这些特性:
* 创建快照
* copy on write:与其覆写，不如拷贝
* subvolumes(有点像分区,partitions++)
* checksums:可以保证数据完整性

缺点：
* 不要用RAID(和标准的RAID不一样)

### 深入介绍容器技术
了解Docker我认为最终要的几个关键词：
* Namespaces
* 联合文件系统
* runc
* linux control group
* 内核能力

#### Namespaces
Docker使用linux namespace技术来实现容器间的资源隔离

|Namespace|syscall|隔离内容|
|---|---|---|
|PID|CLONE_NEWPID|隔离用户的进程|
|UTS|CLONE_NEWUTS|使每个容器有独立的hostname和domain name，使其在网络上可以被视为独立节点|
|IPC|CLONE_NEWIPC|保证容器间的进程交互，信号量，消息队列，共享内存的相互隔离|
|network|CLONE_NEWNET|实现网络隔离，每个net namespace有独立的network devices,ip addresses, ip routing tables,/proc/net目录|
|Mount|CLONE_NEWNS|每个namespace的容器在/proc/mounts的信息中只包含namespace的mount point|
User|CLONE_NEWUSER|允许每个容器有不同的user和group id

一个问题：要**区分不同的shell环境，关键是哪一个namespace的隔离在起作用（系统变量）**

#### 联合文件系统
unionFS是一种分层，轻量级并且高性能的文件系统，它对文件系统的修改作为一次次提交来层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。我们知道Docker镜像可以通过分层来继承，不同的Docker容器可以共享基础文件系统层，再加上自己独有的改动层，大大提高存储效率。Docker支持的联合文件系统包括：
aufs,btrfs,vfs,devicemapper, overlay2

联合文件系统的核心特性：
* copy-on-write

要查看当前docker所使用的文件系统可以：
```shell
docker info | grep 'Storage Driver'
```
Docker容器存在的一个很大问题是：镜像体积在多次提交后变得过于膨胀，该怎么去面对和解决这个问题呢？
首先，为什么一般我们在交互式窗口中使用yum这类的包管理器仅仅是装了一个小工具或者库之后，体积的膨胀却超出了软件体积本身呢？

大家先得掌握一个命令:
```shell
docker istory <image-id>
```
这个命令能够看到镜像的提交历史，其中SIZE那一列的增长最终都会作用到镜像本身，因为在某一个layer提交之后的layer，其删除的磁盘空间实际仍在之前的layer被保留着。

那如何解决这个问题？我们给自己设置一个目标：制作一个满足自己需求的最小容器，其实有几种方法可以实现这个目标：
* from scratch/alpine
* 使用"-v"挂载到本地的某个rootfs
* distroless-docker

这个主题本身就有不小的研究价值，我们放到`最小化容器镜像`来研究

#### runc
容器运行时（container runtime）是实际进行环境隔离的容器运行引擎，![runc](/Download/2499701872-5c238b3a02768_articlex.png)

#### 虚拟机镜像和docker镜像的结构差异
首先对于Docker而言，容器和镜像的差异仅是一个写入层（write layer），Docker镜像的组成实际是多个layer叠加在一个base layer上。这意味着：
* 如果我们使用基于同一操作系统的多个不同镜像，它们会共用同一个base layer
* Docker镜像本身不存在状态，所有对于容器的更改会写到上层的layer中

上面说的这些特性，都是虚机镜像所没有的，接下里让我们了解一下Disk image file formats：磁盘镜像

磁盘镜像是磁盘结构和常规数据的快照。一般来说，磁盘镜像是磁盘上每个扇区的逐位副本，但现在通常的结构是只复制已分配的数据来减少其体积。压缩和重复数据删除的技术被广泛用于减小镜像体积。Virtual disk images（比如VHD和VMDK）通常用于云计算，ISO镜像则通常用于数字取证

#### 最小化容器镜像
首先，来看下"Distroless"容器镜像：
* Alpine
* Distroless
* upx

大家可以试着装下alpine的docker images，不到5MB的磁盘占用
```shell
docker pull gliderlabs/alpine:3.4
```
alpine也是一个linux发行版，但是体积比其他发行版要小许多，究其原因,分析如下：
* 只含有最小的必备依赖（可使用apk info查看有哪些）
* /var/lib/rpm
* systemd
* gconv（字符集）
* coreutils,glibc(使用的musl，这个过于小众),bash都简化了
* 没有预装python


What behind Distroless
* bazel

首先来看下，what behind `docker build`

#### 小小的题外话：upx
UPX（ultimate packer for exe）是一种可执行打包器，可以用来压缩可执行文件的压缩器。通常来说，UPX可以减小程序和DLL的50-70％的体积。

原理相关内容：
* 依赖于NRV压缩库
* /src/stub包含了不同可执行格式的"解压桩"，stub由汇编编写，并被“编译”成C头文件
* UPX的压缩算法是UCL
* UCL不需要为解压分配额外的内存，

想要更细致地了解UPX，可以看这两个链接：
* [upx hacker's guide](github.com/upx/upx/blob/master/README.SRC)
* 



### 其他容器软件

#### Shifter containers for HPC


[项目](github.com/NERSC/shifter)
![软件架构](/screen_shot/Screenshot_20230728_195424_WPS%20Office.jpg)

![性能损失](/screen_shot/Screenshot_20230728_195348_WPS%20Office.jpg)

shifter是专为HPC应用设计的镜像引擎，它由几部分组成：
* 为应用创建执行环境的工具集
* 镜像网管系统，将镜像重新打包以适应squashfs


#### Docker4c
一个专门为C／C++开发设计的容器环境:
[blog](arne-mertz.de/2021/07/docker4c-portable-c-development-environment/)
里面包含的内容包括：
* compiler
* cmake
* Conan

#### 使用lxc文件系统
使用docker容器存在一些问题：
* 容器的根文件系统使用overlayfs，添加文件或者是删除文件，文件系统占用空间都不会减少
* 容器删除后，未提交的修改都会被丢弃，但不断提交会使得镜像体积膨胀

可以从Linux Container社区下载根文件系统tar包，解压系统到宿主机，使用hello world镜像创建容器，将该文件系统挂载到容器


## 调试器

### 自己开发ptrace based debugger

## shell
下面介绍一些对于我工作，生活特别有意义的一些命令行工具（主要是unix类的）
首先会介绍一些存储，网络相关的通用命令，解决磁盘以及网络管理的硬需求

### devbox(Nix)
官方说法“Reproducible development environments wherever you go“，这个概念接近于我前面提到的Portable dev env


### 存储相关的工具

#### lsblk
以树形结构列出所有块设备，输出信息中各列的意义介绍：
* NAME:设备名称，包括磁盘，分区，RAID，LVM
* MAJ:MIN:设备的主次设备号，用于唯一标识设备
* RM：是否为可移动设备，0表示不可移动，1表示可移动
* SIZE：设备大小，以字节为单位
* RO:是否为只读设备，0表示可读写，1表示只读
* TYPE:类型。
  * disk 磁盘
  * part 分区
  * raid RAID
  * lvm LVM(逻辑卷管理器)
* MOUNTPOINT:设备的挂载点，如果未挂载则为空

#### mount
#### e2fsck
用于检查和修复ext4文件系统的命令。


#### fdisk/parted
fdisk是Linux下的磁盘分区工具，可以用来创建，删除，调整MBR分区，下面列出常用方法：
* 

#### hwinfo

### GDB介绍

GDB是GNU组织发布的UNIX平台下的程序调试工具，同样基于ptrace系统调用，使用监控程序检查和改变被追踪者的内存及寄存器。

gdb最重要的几个用途：

* 入侵程序runtime，读写数据
* 主要支持大多数编译型的语言



几个问题：

* 我的GDB workflow

* GDB和Python到底什么关系？
* GDB可以调试Python程序吗？咋做？
* GDB对于Python开发者以及混编开发者最大的作用



#### gdbinit

* gdbinit是什么
* 使用gdbinit可以做到什么



#### GDB调试方法

* 直接启动进程调试 -> gdb [program]
* 调试core文件 -> gdb [program] [core] ： 拿到core查看出问题的调用栈，寄存器信息
* gdb -p pid



#### 常用命令

最好用命令：gdb -tui或**依赖vscode以及gdb-gui等工具**



* 设置断点
  * b <src:line>
  * b func_name

  * 删除断点：delete n（n代表第n个断点）

* 查看堆栈信息

  * 打印最内层：bt n
  * 查看所有线程：thread apply all bt

* 线程

  * 转到某线程： thread thread_number

* 栈帧

  * frame n

* 执行下一步命令（单步）

  * next




#### gdb奇巧

* gdb --args



#### 使用Python扩展gdb

##### case1：深入Python进程，做些恶作剧

```shell
./configure --with-python
# 在gdb进程中嵌入Cpython解释器
# 这个命令+python debug symbols
```

GDB的Python扩展能够给到我们什么：

* 在GDB中访问高层级的CPython解释器信息
* 在Python代码中访问GDB命令
* 定制化GDB commands



常用的访问Python信息的GDB命令：

* python [command]
* py-list
* py-bt
* py-up/py-down
* pylocals
* py-print



```shell
gdb -p <pid> -x gdb_commands.py
# 让gdb内的Cpython读取py_ext，获取新命令
```



```python
import gdb
# gdb.execute()是王道API，可以直接指定gdb去做任何事，有点像subprocess.Popen
gdb.execute()
# 那么,gdb里的 `call <expr>`又有什么讲究呢？
# 1.首先gdb会去查表，查符号表，找到所有函数的符号
# 2.查表会找到函数的对应地址，然后强制进程跳转到对应内存地址执行相应指令
# 3.configure with Cpython允许你call <C API>
```



一些重要的C API

* PyRun_SimpleString("<any python string>")
* PyGILState_Ensure()
* PyGILState_Release()



##### case2：进一步封装C++对象，inspect them





## REPL

### 主题：C++的REPL实现

#### C++语言解释层

详情请关注：https://compiler-research.org/libinterop/

这里将一些个人认为重要的观点谈一下。

Python在科学计算以及范·机器学习领域内有很强大的生态，一个非常关键的因素就是其可交互性，结合其本身的胶水特性，Python在进行各种research的工作中可谓是神器。

依赖Pybind11这样的构筑在Python C-API上的C++ API，Python得以将native语言的高性能优势发挥出来。然而，这样的做法存在局限性，首先是这种binding方法属于静态的binding，效率上存在缺陷，另一方面是“trampoline functions”的问题：

```
在 Pybind11 和其他类似工具中，要在 C++ 类型和 Python 类型之间建立映射关系，通常需要使用类似于 trampoline 的方法。简单来说，trampoline 函数是一个中间层，负责将 Python 对象的调用转发到底层的 C++ 对象上。在 Python 中，当子类继承自父类时，通常需要将子类的对象向上转换为父类的对象，因此需要在 C++ 和 Python 中使用不同的 trampoline 函数来处理继承关系。这些 trampoline 函数通常会在绑定代码中生成，以确保 C++ 对象的函数在 Python 中的调用能够正确地处理继承语义。

然而，在某些情况下，这些 trampoline 函数可能需要重复定义和生成，以满足不同的继承关系。这些被称为 "redundant trampoline functions"（冗余的 trampoline 函数），因为它们可能会在代码中重复出现，导致代码变得冗长和难以维护。举个例子，如果一个 C++ 类型被多个 Python 类型继承，那么需要为每个 Python 类型都定义一个 trampoline 函数，这可能导致许多相似的函数定义。这是一种常见的问题，可能会导致代码的不必要的膨胀和维护成本的增加。
```

另一方面，很多人认为动态绑定的效率一定比静态绑定要低，这实际上是个误区。



### cling介绍

C++是难以学习的一门语言，为了更好的掌握它，一些工具可能会帮到你很多。比如C++ REPL cling

相比于C++，Python会更容易学习，实际上这不单是语言复杂度的问题，我认为还有一个很原因是Python对于新人来说，**可交互性会更好**，自带REPL运行模式的解释器，而且这是一种常用模式，比如我们所熟知的Jupyter也是基于这种使用习惯所诞生的产品。REPL使我们可以更频繁地与Python语言本身交互，进行数据的探索，对于科学计算，数据分析类的应用而言，这至关重要，另一方面，这种探索也能快速提高一个人对于语法以及词法的熟练程度。



#### 原理介绍

参考文章https://blog.llvm.org/posts/2020-11-30-interactive-cpp-with-cling/

**Cling支持完整的C++特性**。包括模板，lambdas，虚拟继承。而Cling是在Clang和LLVM编译器架构上开发的一款应用。



![image-20230330004813608](statics\image-20230330004813608.png)

* 该工具通过交互式提示符或者一些REPL接口处理增量输入
* 将clang发送给其依赖的clang库进行编译，clang编译输入内容，将其转化为AST（②，③）
* 特殊情况下，AST要做进一步的转换（④）
* 将AST转化为LLVM-IR（⑤），LLVM-IR再次提交给JIT编译架构，去运行特定函数（⑥）
* 最终，生成的机器码（⑦）被提交给对应的处理硬件



C++本身的设计并没有考虑交互性，全局scope的声明执行，报告执行结果，实体的重定义是体现REPL用户友好性的最重要的三个特性。



#### 常用操作

##### 学习C++语法知识



##### jupyter notebook打开

启动对应的容器命令

```shell
docker run -it --network host --gpus all /bin/bash
```



启动jupyter notebook

```shell
setsid jupyter notebook --port=8888 --no-browser --ip=0.0.0.0 --allow-root
```



##### 写CUDA



##### 调试动态库文件

以dlib的matrix对象为例，演示如何调试库中的对象

* 以debug模式编译dlib，并且生成动态库二进制文件
* 



##### 像Python一样写use case



##### 查看数据结构，数据类型



## Profiling tools

### libunwind

libunwind是内存分析工具memray所依赖的核心组件之一，



## compiler

### loopy介绍



## AI assistance

### chat-gpt

下面给出一些图例来说明chat-gpt在不同场景下对于开发的帮助（基于gpt-3.5）。

#### 学习编程语言的特性

